---
title: "网络协议设计 — 2 — 整体思路"
description: 
date: 2024-11-09
image: 
math: 
license: 
hidden: false
comments: true
draft: false
categories:
    - 网络协议设计
---

# 协议设计思路
协议设计的5大任务：
- `读取报文` -> `解析报文` -> `处理数据` -> `响应报文` -> `发送响应报文`;   
该篇章梳理协议设计过程中的关键接口，但是不深入讲解代码实现。

------

&emsp;&emsp;我们一般采用异步操作，在检测到Socket有数据可以读取时，此时解析器读取并解析报文。从读写的角度看，协议设计过程中有两套读写函数，当有网络数据可以读取时，要触发一次`解析任务`：  
```c
int parser_do_read(struct parser *parser);   // 触发一次解析任务
```
&emsp;&emsp;在一次解析任务中，解析器需要`读取数据 -> 解析 -> 读取数据 -> 解析 -> 读取数据 -> 解析`，如此多个回合，尤其是协议头的长度不固定时。此时又涉及到了“读取操作”，这个读取是真的读取数据，但是`解析报文`和`读取数据`，这两件事的代码不能直接干到一起的，所以解析器在设计的时候就要提供数据的**读取**与**发送**的回调接口，在创建解析器时传入用户定义的读写函数，在用户回调函数中完成实际的读写逻辑，阻塞还是非阻塞，直接从网络读取，还是从指定的缓存区中读取。    
&emsp;&emsp;根据协议头记录的报文长度，读取到整个报文后，就进入数据处理环节，说白了，就是根据报文的类型将报文携带的数据交给对应的处理程序。此说来，对于上面给出的函数，它的代码就应该是：“通过多次读回调获取数据，直到获取到整个报文，然后调用对应的处理程序进行处理”，至于数据是如何处理的那就是另外的业务了，和协议没有关系了。  
&emsp;&emsp;数据处理完成后会有一个结果，我们要将结果（可能是一个状态字段，也可能携带数据）响应给对方。此时需要将处理结果打包并发送给对方，如果有多种类型的报文，不同类型的报文的头部字段以及头部长度可能有所不同，这样打包时传入的参数的类型以及数量有所不同，所以一般设计多个打包函数，但是这些打包函数不会直接发送报文，而是将打包好的报文写入到一个`发送队列`中：   
```c
static void parser_queue(struct parser         *parser_pub,
                         uint32_t               type, 
                         uint64_t               id, 
                         void                  *type_header_in,
                         uint8_t               *data_in, 
                         int                    data_len )；
```
&emsp;&emsp;通过调用上面的函数，报文就保存到了发送队列的中。那么，什么时候发送呢？每一次调用`parser_do_read()`并成功返回后，或者数据处理完成后，就要调用发送函数：   
```c
int parser_do_write(struct parser *parser);  // 触发一次发送任务
```
&emsp;&emsp;该函数内部要做的事情就是遍历队列，从队列中读取报文并发送。每一次调用该函数都会将队列中的报文全部发送，并修改队列为空。     
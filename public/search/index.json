[{"content":"单节点部署 一个节点就是一台物理设备，实际安装过程和安装一个操作系统基本一样，安装后：\n集群部署 需要至少2台物理设备，没有条件，先不做了。\n","date":"2025-05-27T22:46:37+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC%E4%BA%8C%E8%8A%82-pve%E8%8A%82%E7%82%B9%E9%83%A8%E7%BD%B2/","title":"第二节 Pve节点部署"},{"content":"1. 基本介绍 Proxmox VE（Proxmox Virtual Environment），奥地利企业“Proxmox Server Solutions GnbH”开发的虚拟化产品，基于Debian，于2008年发布第一个版本稳定版Proxmox VE 1.0。\n2. 功能特性 服务器虚拟化 基于KVM技术提供虚拟化支持，可以运行Linux和Windows操作系统。\nLinux容器 基于LXC技术提供Linux容器支持，通过PCT(Proxmox Container Tools)就可以直接使用Proxmox VE的存储资源和网络资源。\n基于Web的管理\n通过web登陆对服务器进行管理，不需要安装客户端软件。\n高可用\n基于Linux HA技术。\n去中心化\nPrexmox VE基于数据库设计了一种专用的文件系统用于保存配置文件，这个文件系统通过Corosync将配置文件实时复制到PVE集群的所有节点，不再需要部署一个单独的管理端服务器，这就是PVE的去中心化设计。\n集成Ceph分布式存储\n通过Web端即可运行管理Ceph。\n集成备份与还原\n企业级备份\nProxomx Backup Server与集成的备份与还原功能相比更强大。\n集成防火墙 通过Web页面对虚拟机以及容器的网络流量进行过滤。\n支持多种身份认证\n包括Microsoft活动目录、LDAP、双因素身份认证等等。\n","date":"2025-05-27T21:55:22+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC%E4%B8%80%E8%8A%82-pve%E4%BB%8B%E7%BB%8D/","title":"第一节 PVE介绍"},{"content":" 1. 初步认识 2. 自定义比较函数 3. 迭代器 4. 插入元素 4.1. insert与emplace 4.2. emplace_hint 5. 删除元素 5.1. erase 6. 访问元素 6.1. contains 6.2. find 7. 修改元素 7.1. extract 1. 初步认识 由于set底层是红黑树，因此set中的元素必须支持比较大小，对于自定义类型需要重载“\u0026lt;”，或者自定义一个比较函数并在创建set对象时指定。\n1 2 3 4 5 template\u0026lt; class Key, class Compare = std::less\u0026lt;Key\u0026gt;, class Allocator = std::allocator\u0026lt;Key\u0026gt; \u0026gt; class set; 从类木板的声明来看，Compare是用于元素比较的函数，Allocator是分配器，这两个都有默认的参数，所以我们可以如下创建set对象：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # include \u0026lt;iostream\u0026gt; # include \u0026lt;set\u0026gt; int main() { /** * 初始化时，元素顺序不重要，set会进行排序； * 元素必须支持比较大小，set会去除重复元素； */ std::set\u0026lt;int\u0026gt; s{66, 99, 88}; for (auto ptr = s.begin(); ptr != s.end(); ++ptr) { std::cout \u0026lt;\u0026lt; *ptr \u0026lt;\u0026lt; std::endl; } } 代码输出:\n1 2 3 66 99 88 由于set底层使用是红黑树，并且代码输出结果为升序，因此set遍历方式为中序遍历。\n2. 自定义比较函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Str { int x; } bool MyCompare(const Str \u0026amp;a, const Str \u0026amp;b) { return a.x \u0026lt; b.x; //a\u0026lt;b时返回true } int main() { std::set\u0026lt;Str, decltype(\u0026amp;MyCompare)\u0026gt; s{Str{Str{66}, Str{99}}, Compare}; } 3. 迭代器 set迭代器所指向的对象是const的，因此不能通过迭代器修改元素。\n4. 插入元素 4.1. insert与emplace 1 2 3 4 5 6 int main() { std::set\u0026lt;Str, decltype(\u0026amp;MyCompare)\u0026gt; s{Str{Str{66}, Str{99}}, Compare}; s.insert(Str{88}}); s.emplace(77); } 根据参数来看，insert是先构造一个Str对象,然后拷贝或者移动到s中，而emplace，直接在s中构造一个Str对象。\n4.2. emplace_hint 1 2 template\u0026lt; class... Args \u0026gt; iterator emplace_hint( const_iterator hint, Args\u0026amp;\u0026amp;... args ); 通过hint参数，告诉系统，新元素大约要插入到那里，参数\u0026quot;Args\u0026amp;\u0026amp;\u0026hellip; args\u0026quot;用来构造新元素，这样能够减少比较次数，但是要求hint准确，如果hint不准确，可能导致效率更低。\n5. 删除元素 5.1. erase 1 2 3 size_type erase( const Key\u0026amp; key ); // (constexpr since C++26) iterator erase( const_iterator pos ); // (since C++11) (constexpr since C++26) iterator erase( const_iterator first, const_iterator last ); // (since C++11) (constexpr since C++26) 6. 访问元素 6.1. contains 1 2 3 4 bool contains( const Key\u0026amp; key ) const; // (since C++20) (constexpr since C++26) template\u0026lt; class K \u0026gt; bool contains( const K\u0026amp; x ) const; // (since C++20) (constexpr since C++26) 如果包含就返回true，否则返回false。\n6.2. find 1 2 3 4 5 6 7 8 iterator find( const Key\u0026amp; key ); // (constexpr since C++26) const_iterator find( const Key\u0026amp; key ) const; // (constexpr since C++26) template\u0026lt; class K \u0026gt; iterator find( const K\u0026amp; x ); // (since C++14) (constexpr since C++26) template\u0026lt; class K \u0026gt; const_iterator find( const K\u0026amp; x ) const; // (since C++14) (constexpr since C++26) 如果找到元素就返回该元素的迭代器，否则返回end()。\n7. 修改元素 由于set迭代器是const的，因此不能通过迭代器修改元素。\n7.1. extract 1 2 3 4 5 6 node_type extract( const_iterator pos ); // (since C++17) (constexpr since C++26) node_type extract( const Key\u0026amp; k ); // (since C++17) (constexpr since C++26) template\u0026lt; class K \u0026gt; node_type extract( K\u0026amp;\u0026amp; x ); // (since C++23) (constexpr since C++26) 使用方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;algorithm\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;string_view\u0026gt; #include \u0026lt;set\u0026gt; void print(std::string_view comment, const auto\u0026amp; data) { std::cout \u0026lt;\u0026lt; comment; for (auto datum : data) std::cout \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; datum; std::cout \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } int main() { std::set\u0026lt;int\u0026gt; cont{1, 2, 3}; print(\u0026#34;Start:\u0026#34;, cont); // Extract node handle and change key auto nh = cont.extract(1); nh.value() = 4; print(\u0026#34;After extract and before insert:\u0026#34;, cont); // Insert node handle back cont.insert(std::move(nh)); print(\u0026#34;End:\u0026#34;, cont); } 程序输出：\n1 2 3 Start: 1 2 3 After extract and before insert: 2 3 End: 2 3 4 显然，extract类似于先erase再insert，但是extract利用了已经创建好的对象，省去了创建对象的开销。\n","date":"2025-05-26T21:55:17+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC4%E8%8A%82-%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8%E4%B9%8Bset/","title":"第4节 - 关联容器之Set"},{"content":"1. Arch 首先，极简的说，DeskFlow的跨平台抽象层如下(先忽略类成员)： 2. Arch类设计 Arch类是单例类，他们这个单例有点问题，但是人家确实是这么设计的。\n2.1. Arch类声明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 // arch.h class Arch : public ARCH_CONSOLE, public ARCH_DAEMON, public ARCH_LOG, public ARCH_MULTITHREAD, public ARCH_NETWORK, public ARCH_SLEEP, public ARCH_STRING, public ARCH_TIME { public: // 构造函数是public的，但是没有问题，后面会分析 Arch(); Arch(Arch *arch); virtual ~Arch(); virtual void init(); static Arch *getInstance(); static void setInstance(Arch *s) { s_instance = s; } private: static Arch *s_instance; //静态私有单例 }; 2.2. Arch类实现 1 Arch *Arch::s_instance = NULL; // 俄汉模式，初始化静态私有单例 2.3. 单例构造 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 Arch::Arch() { assert(s_instance == NULL); // 只能创建一个Arch对象 s_instance = this; } // 危险的代理构造，实际并没有使用 Arch::Arch(Arch *arch) { s_instance = arch; // 允许外部接管实例 } Arch::~Arch() { } 在DeskFlow软件中，不管是Clinet还是Server，都只在程序启动时创建一个Arch对象，无他，代码也是仅在DeskFlow工程内部使用，所以就是public也不影响。\n2.4. 单例初始化 1 2 3 4 5 6 7 void Arch::init() { ARCH_NETWORK::init(); #if SYSAPI_WIN32 ArchMiscWindows::init(); #endif } 2.5. 单例访问 1 2 3 4 5 Arch *Arch::getInstance() { assert(s_instance != NULL); return s_instance; } 3. 单例使用 1 2 Arch arch; arch.init(); ","date":"2025-05-25T19:39:48+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC%E4%B8%89%E8%8A%82-deskflow%E8%B7%A8%E5%B9%B3%E5%8F%B0%E6%8A%BD%E8%B1%A1%E5%B1%82/","title":"第三节 - DeskFlow跨平台抽象层"},{"content":"分支管理 master分支:\n用于生产环境的部署，不允许直接push分支，由release分支或者hotfix分支合并。 hotfix分支:\n针对线上紧急问题进行修复的分支，以master分支为基线创建的，修复完成后合并到dev分支、master分支。 release分支:\n预发布分支，UAT测试阶段使用，一般由test分支或hitfix分支合并。 dev分支:\n开发分支，最新版本迭代代码，包括bug修复后的代码。 feature分支:\n基于dev分支在本地创建，每个开发人员的本地分支，针对各自的功能进行开发，开发完成合并到dev分支，并删除该fearure分支，feature是每个开发人员的本地分支，不可推送到远程，只能在本地合并到dev分支，然后推送dev分支。\n","date":"2025-05-25T17:04:00+08:00","permalink":"https://zuoco.github.io/p/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","title":"软件开发版本管理"},{"content":" Hello-GitHub Open-GitHub ","date":"2025-05-25T14:22:52+08:00","permalink":"https://zuoco.github.io/p/%E8%B5%84%E6%BA%90/","title":"资源"},{"content":"FreeCAD - 1.0.1 https://github.com/FreeCAD/FreeCAD\n下面是freecad的多个realease版本介绍: Windows平台：\n1 2 3 4 FreeCAD_1.0.1-conda-Windows-x86_64-installer-1.exe FreeCAD_1.0.1-conda-Windows-x86_64-installer-1.exe-SHA256.txt FreeCAD_1.0.1-conda-Windows-x86_64-py311.7z # 便携式 FreeCAD_1.0.1-conda-Windows-x86_64-py311.7z-SHA256.txt 其中conda表示该版本基于 Conda 包管理器构建，py311表示依赖Python-3.11。\nLinux平台：\n1 2 3 FreeCAD_1.0.1-conda-Linux-x86_64-py311.AppImage FreeCAD_1.0.1-conda-Linux-x86_64-py311.AppImage-SHA256.txt FreeCAD_1.0.1-conda-Linux-x86_64-py311.AppImage.zsync 安装 以Windows平台为例： 下载FreeCAD_1.0.1-conda-Windows-x86_64-py311.7z，解压后，FreeCAD_1.0.1\\bin\\freecad.exe就是可执行文件。 ","date":"2025-05-25T13:53:51+08:00","permalink":"https://zuoco.github.io/p/freecad%E5%AE%89%E8%A3%85/","title":"FreeCAD安装"},{"content":" ","date":"2025-05-21T23:41:24+08:00","permalink":"https://zuoco.github.io/p/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86-%E7%AC%AC1%E8%8A%82/","title":"内存管理 第1节"},{"content":"安装vmstat 1 sudo dnf install sysstat # Fedora 启用sysstat服务 1 2 sudo systemctl start sysstat sudo systemctl enable sysstat 查看内存信息 1 sar -r 1 10 1 2 3 4 5 6 7 zcli@fedora:~/myBlog/notebooks$ sar -r 1 2 Linux 6.14.6-200.fc41.x86_64 (fedora) 2025年05月21日 _x86_64_\t(16 CPU) 22时27分50秒 kbmemfree kbavail kbmemused %memused kbbuffers kbcached kbcommit %commit kbactive kbinact kbdirty 22时27分51秒 21377908 26044624 5275184 16.41 5844 5071508 24039676 59.29 6736456 2538556 800 22时27分52秒 21379140 26045856 5273952 16.40 5844 5071508 24039692 59.29 6736584 2538556 808 平均时间: 21378524 26045240 5274568 16.40 5844 5071508 24039684 59.29 6736520 2538556 804 字段含义：\nkbmemfree（空闲物理内存）\n系统当前未被使用的物理内存，直接可分配。\nkbavail（可用内存）\n包含空闲内存和可回收的缓存/缓冲（如文件缓存），反映实际可分配给进程的内存。\nkbmemused（已用内存）\n内核和进程已占用的物理内存（不包含缓存/缓冲）。\n%memused（内存使用率） 物理内存使用率较低，系统内存压力小。\nkbbuffers（缓冲区内存） 内核缓冲区用于临时存储磁盘块数据（如文件系统元数据）。\nkbcached（缓存内存） 文件缓存，加速文件访问，可被快速回收供进程使用。\nkbcommit（提交内存总量）\n当前系统所有进程申请的内存总和（包括物理内存和交换空间）。\n%commit（提交内存占比） 提交内存占总物理内存+交换空间的59%，无内存耗尽风险。\nkbactive（活跃内存）\n近期被频繁访问的内存页（如进程代码、数据）。\nkbinact（非活跃内存）\n长时间未使用的内存页，可被回收（如缓存旧文件）。\nkbdirty（脏页）\n需写回磁盘的修改过的内存页，数值低说明I/O压力小。\n提交内存 脏页 ","date":"2025-05-21T22:01:50+08:00","permalink":"https://zuoco.github.io/p/vmstat/","title":"vmstat"},{"content":"1. 什么是OOM 在内存不足时，内存管理系统会回收内核中可以释放的内存，当实在没有内存可用的时候，就会进入OOM（Out of Memory）状态，内存管理系统会执行OOM Killer，依据一定的规则杀死一些进程来释放内存，对于个人PC来说，这都不是个事儿，但对于服务器，有可能就会将重要的业务进程给干死了，所以有的服务器会将sysctl的vm.panic_on_omc参数设为1，当发生OOM时强制关闭系统，如果设置为0(默认)，在OOM时就会运行OOM Killer。\nOOM Killer机制 OOM Killer机制依靠两个因素选择要杀的进程，oom_score和oom_score_adj，其中oom_score是内核通过进程的内存消耗计算出来的，oom_score_adj（取值-1000 ~ 1000）是用户用来干预oom的（用户权重），内核会向oom_score + oom_score_adj值最高的进程发送关闭信号。\noom Killer代码 内核代码：linux-6.14.6/mm/oom_kill.c\nOOM杀手算法的评分机制: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 long oom_badness(struct task_struct *p, unsigned long totalpages) { long points; long adj; // 1. 排除不可杀进程 if (oom_unkillable_task(p)) return LONG_MIN; p = find_lock_task_mm(p); if (!p) return LONG_MIN; // 2. 获取用户权重，并判断该进程是否可杀 adj = (long)p-\u0026gt;signal-\u0026gt;oom_score_adj; if (adj == OOM_SCORE_ADJ_MIN || test_bit(MMF_OOM_SKIP, \u0026amp;p-\u0026gt;mm-\u0026gt;flags) || in_vfork(p)) { task_unlock(p); return LONG_MIN; } // 3. 基础评分 = 物理内存 + 交换分区 + 页表内存 points = get_mm_rss(p-\u0026gt;mm) + get_mm_counter(p-\u0026gt;mm, MM_SWAPENTS) + mm_pgtables_bytes(p-\u0026gt;mm) / PAGE_SIZE; task_unlock(p); // 4. 归一化调整值 = OOM评分调整值 * 总内存/1000 adj *= totalpages / 1000; // 5. 最终评分 points += adj; return points; } 查找oom最大的进程 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 static void select_bad_process(struct oom_control *oc) { oc-\u0026gt;chosen_points = LONG_MIN; if (is_memcg_oom(oc)) mem_cgroup_scan_tasks(oc-\u0026gt;memcg, oom_evaluate_task, oc); else { struct task_struct *p; rcu_read_lock(); // 否则遍历系统所有进程，通过oom_evaluate_task评估每个进程，若返回true则立即停止遍历（找到候选进程） for_each_process(p) if (oom_evaluate_task(p, oc)) break; rcu_read_unlock(); } } 杀死进程 1 2 3 4 static void oom_kill_process(struct task_struct *victim, const char *message) { // 杀死进程，太多了，就不放了 } /proc/sys/vm/oom_kill_allocating_task 写入1表示优先杀死导致内存不足的任务，而不是选择评分最高的任务。\n","date":"2025-05-21T20:53:24+08:00","permalink":"https://zuoco.github.io/p/%E5%86%85%E6%A0%B8oom%E6%9C%BA%E5%88%B6/","title":"内核OOM机制"},{"content":"占位 ","date":"2025-05-21T20:43:36+08:00","permalink":"https://zuoco.github.io/p/c-20%E5%85%B3%E9%94%AE%E5%AD%97/","title":"C++20关键字"},{"content":"占位坑 ","date":"2025-05-21T20:39:47+08:00","permalink":"https://zuoco.github.io/p/ollama%E5%9F%BA%E7%A1%80/","title":"Ollama基础"},{"content":"MNN 是阿里巴巴开发的一款推理引擎，MNN可以将主流训练框架的产物转换为MNN模型，得到模型后就可以部署到端侧。高性能、轻量化、跨平台，说白了就是给端侧部署搞的，可以在手机、PC、嵌入式系统上运行，前途无量。\n","date":"2025-05-20T22:20:48+08:00","permalink":"https://zuoco.github.io/p/mnn/","title":"MNN"},{"content":"1. 动态分析 就是我们面对着正在运行的Linux系统，然后通过一些命令，查看正在运行的进程占用内存的情况。\n1.1. ps命令查看内存使用量大的进程 1 ps -eo pid,comm,%mem --sort -%mem | head -n 10 参数解释：\n1 2 3 4 -e：显示所有进程。 -o：显示制定的列，pid(进程ID),comm(进程名),%mem(进程使用的内存百分比) --sort -%mem：按照内存使用百分比降序排序。 head -n 10：显示前10行。 1.2. free命令 1 2 3 4 zcli@fedora:~$ free -h total used free shared buff/cache available Mem: 30Gi 5.4Gi 21Gi 79Mi 4.4Gi 25Gi Swap: 8.0Gi 0B 8.0Gi 1 2 3 4 zcli@fedora:~$ free -m total used free shared buff/cache available Mem: 31400 5554 21799 86 4564 25845 Swap: 8191 0 8191 2. 内核的OOM机制 (后面会文章单独分析oom机制，这里简单介绍)OOM（Out of Memory）\n机制是为了应对系统内存耗尽的情况而设计的一种保护机制。当系统内存资源紧张到无法为新的内存分配请求提供足够的空间时，OOM Killer会被触发，依据一定的规则杀掉一些进程来释放内存。\n查询OOM事件： 1 $ dmesg | grep -i \u0026#34;out of memory\u0026#34; oom_score分数： 1 2 3 4 zcli@fedora:/proc/11991$ ls -al | grep oom -rw-r--r--. 1 root root 0 5月20日 22:34 oom_adj # 新的内核中已经弃用。 -r--r--r--. 1 root root 0 5月20日 22:34 oom_score # 只读文件，保存了当前进程的oom_score分数。 -rw-r--r--. 1 root root 0 5月20日 22:34 oom_score_adj # 用户自定义的oom_score_adj值，用于干预oom_score分数的计算。 3. 检查内存碎片化 相关信息位于文件中：\n1 2 3 /proc/buddyinfo /proc/vmstat /proc/meminfo 3.1. buddyinfo文件 看一下文件内容：\n1 2 3 4 zcli@fedora:~$ cat /proc/buddyinfo Node 0, zone DMA 0 0 0 0 0 0 0 0 1 1 2 Node 0, zone DMA32 8 11 6 7 7 7 10 8 7 9 573 Node 0, zone Normal 1958 592 249 207 133 32 98 87 36 11 4422 每一行的格式为：\n1 Node \u0026lt;node_id\u0026gt;, zone \u0026lt;zone_name\u0026gt; \u0026lt;order0\u0026gt; \u0026lt;order1\u0026gt; ... \u0026lt;order10\u0026gt; Node 0： 表示单个 NUMA 节点（无 NUMA 架构时仅一个节点）。 zone \u0026lt;zone_name\u0026gt;：内存区域类型，常见类型包括：\nDMA：直接内存访问（DMA）区域，用于 32 位设备的内存访问（地址范围有限）。 DMA32：扩展的 32 位 DMA 区域（地址范围比 DMA 更广）。 Normal：普通内存区域，用于大多数内存分配。 \u0026lt;orderN\u0026gt;：\n表示阶（order）为 N 的空闲内存块数量(N从0开始)。每个阶的内存块大小为 2^N * PAGE_SIZE（通常 PAGE_SIZE = 4KB）\n对于32位的系统:\n1 2 3 DMA Normal HighMem # 高内存区，在32位系统上用于扩展可寻址内存范围，对于64位系统，这个区域可能不存在。 碎片化判断:\n低阶空闲块越多，高阶阶空闲块越少代表内存碎片化越严重。\n3.2. /proc/vmstat文件 部分字段：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 nr_free_pages 718778　#　当前系统中空闲（未分配）的物理页面总数。每个页面的大小通常是 4KB，但这也取决于具体的系统架构。 pgalloc_dma 0 pgalloc_normal 10593690 # 从普通内存区（Normal zone）成功分配的物理页面总数 pgalloc_high 72600886 pgsteal_dma 0 pgsteal_normal 26597 # 回收的页面数量 pgsteal_high 0 # 为 0，说明没有从 HighMem 回收页面 compact_stall 1 # 表示由内存整理操作,而暂停分配器（allocator stalls）的次数。 # 当内核需要分配一个较大的连续内存块但无法立即找到足够的连续页面时，它会触发内存整理操作来尝试重组内存，使得更多的连续内存块可用。 # 如果这个过程花费的时间超过了内核设定的阈值，就会记录一次 compact_stall。 compact_fail 0 # 表示内存整理失败的次数。即使进行了内存整理，有时也可能无法找到足够大的连续内存块来满足分配请求。 compact_success 0 # 表示内存整理成功的次数。即通过内存整理操作成功创建了足够大的连续内存块，从而满足了分配请求。 # 既没有失败，也没有成功，可能是没有开启内存整理功能。 allocstall_dma 0 # 表示有几次因内存分配失败而进入 stall 状态的情况。 allocstall_dma32 0 allocstall_normal 0 allocstall_movable 0 allocstall_device 0 3.3. /proc/meminfo 1 2 3 4 5 6 7 8 9 10 MemTotal: 4005176 kB　# 总的物理内存 MemFree: 2875924 kB　# 剩余内存 Buffers: 40576 kB　Cached: 500332 kB SwapCached: 0 kB # 6. 32位系统 HighTotal: 3143004 kB　# 加上LowTotal等于MemTotal, 在64位系统中，这一部分主要是为了兼容性保留的概念，在实际应用中意义不大。 HighFree: 2140940 kB # 加上LowFree等于MemFree LowTotal: 862172 kB # 标识低端内存区域的总容量为 862,172 KB（约 842 MB）。低端内存可以直接映射到内核地址空间。 LowFree: 734984 kB 3.4. 32位系统的高低内存划分 3.4.1. 32系统的内存划分 Low Memory：约896MB，内核直接映射。 High Memory：剩余约3.1GB，需动态映射。\nLow Memory：\n内核可以直接映射到其虚拟地址空间的物理内存（即内核的直接映射区），这部分物理内存通过线性映射（固定偏移）转换到内核虚拟地址空间，例如，物理地址0x00000000对应内核虚拟地址0xC0000000（3GB处）。这部分内存无需动态映射(内核可直接访问，无需页表切换或临时映射)，最多1GB(与内核空间大小一致)，但实际受内核保留区域（如vmalloc区、固定映射区等）影响，通常约为896MB，用于存放内核关键数据结构（如页表、进程描述符）、代码、DMA缓冲区等必须常驻内存的内容。\nHigh Memory:\n超出内核直接映射区（Low Memory）的物理内存，需通过动态映射机制才能被内核访问，当物理内存超过1GB（或实际约896MB）时，额外内存属于High Memory。动态内存映射机制包括，(1)临时映射(kmap)使用kmap()和kunmap()函数将High Memory页临时映射到内核的“固定映射区”，适用于短时间访问。(2).永久映射(pkmap)通过kmap_atomic()在“永久映射区”建立映射，常用于中断上下文等不允许阻塞的场景。(3)vmalloc区，分配非连续的物理内存，映射到虚拟地址空间，用于大块内存请求。High Memory需要动态映射/解除映射，存在性能损耗。主要是用户进程分配物理页（通过页表映射到用户空间），或内核临时访问大内存（如文件缓存）用到。\n相对于64位系统：\n64位地址空间远大于物理内存需求（如x86_64支持48位虚拟地址，256TB），直接映射所有内存，内核可通过直接映射区（physmap）线性映射全部物理内存，无需High Memory概念。\n3.5. /proc/sys/vm/min_free_kbytes 文件中的值定义了在系统中应始终保持空闲的最小内存量（以KB为单位）。这个参数对于防止内存完全耗尽，确保系统即使在高负载下也能平稳运行至关重要。当可用内存降至 min_free_kbytes 设置的阈值之下时，Linux 内核的内存回收机制会主动尝试释放内存，例如通过回收缓存或交换出不活跃的页面到磁盘。\n4. 内存压缩（整理） 如果内存碎片化严重，可以通过调整内存压缩（整理）的方式来解决，。\n1 2 root@fedora:~# ls -al /proc/sys/vm/compact_memory --w-------. 1 root root 0 5月20日 22:44 /proc/sys/vm/compact_memory # 写入1或0 0： 禁止内存整理功能（默认值）。 1： 启用内存压缩，并触发一次内存整理操作。\n可以手动触发内存整理操作(临时措施)： 1 echo 1 \u0026gt; /proc/sys/vm/compact_memory 或者:\n1 sudo susctl vm.compact_memory=1 永久措施: 将下面内容写入/etc/sysctl.conf文件中：\n1 vm.compact_memory=1 然后执行：\n1 sudo sysctl -p 但是要注意:\n内存压缩是一个同步、阻塞式的操作，会增加CPU和IO开销，不建议在生产环境频繁使用。 内存压缩需要启用内核CONFIG_COMPACTION选项，可以通过以下命令查看该功能是否启用： 1 grep CONFIG_COMPACTION /boot/config-$(uname -r) # 输出CONFIG_COMPACTION=y表示启用了该功能。 ","date":"2025-05-20T00:18:27+08:00","permalink":"https://zuoco.github.io/p/%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E5%86%85%E6%A0%B8%E6%97%A5%E5%BF%97/","title":"内存分析常用工具、内存相关内核日志"},{"content":"1. AI模型的本地部署 以Qwen32-14B为例。\n2. 主机 主机：天钡 GEM12 Pro CPU: AMD Ryzen 7 PRO 8845HS 内存：32GB 3. 系统 发行版：Fedora Linux 41 (Workstation Edition) 内 核：6.14.6-200.fc41.x86_64 4. 显卡 NVIDIA GTX 5060 Ti 16GB\n5. 显卡驱动安装 根据下面网页的提示选择系统版本后，下方会给出对应的安装过程，根据指示安装即可。 https://developer.nvidia.com/cuda-downloads?target_os=Linux\u0026target_arch=x86_64\u0026Distribution=Fedora\u0026target_version=41\u0026target_type=rpm_local 安装完成后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 zcli@fedora:~$ nvidia-smi Sun May 18 22:05:08 2025 +-----------------------------------------------------------------------------------------+ | NVIDIA-SMI 575.51.03 Driver Version: 575.51.03 CUDA Version: 12.9 | |-----------------------------------------+------------------------+----------------------+ | GPU Name Persistence-M | Bus-Id Disp.A | Volatile Uncorr. ECC | # 第一行标题 | Fan Temp Perf Pwr:Usage/Cap | Memory-Usage | GPU-Util Compute M. | # 第二行标题，其中Perf表示当前性能状态（P0 ~ P15，P0 是最高性能，P12/P15 是节能模式） | | | MIG M. | # 第三行标题 |=========================================+========================+======================| | 0 NVIDIA Graphics Device On | 00000000:01:00.0 On | N/A | # 第一行数据，对应第一行标题 | 0% 47C P5 10W / 180W | 1346MiB / 16311MiB | 0% Default | # 第二行数据，对应第二行标题 | | | N/A | # 第三行数据，对应第三行标题 +-----------------------------------------+------------------------+----------------------+ +-----------------------------------------------------------------------------------------+ | Processes: | | GPU GI CI PID Type Process name GPU Memory | # 进程列表 | ID ID Usage | |=========================================================================================| | 0 N/A N/A 36667 G /usr/bin/gnome-shell 393MiB | # 几个使用GPU进程的进程以及使用的显存 | 0 N/A N/A 37509 C+G /usr/bin/ptyxis 73MiB | | 0 N/A N/A 37546 G /usr/bin/Xwayland 38MiB | | 0 N/A N/A 37828 G ...ess --variations-seed-version 207MiB | | 0 N/A N/A 38479 C+G /opt/microsoft/msedge/msedge 6MiB | | 0 N/A N/A 38542 G ...per --variations-seed-version 415MiB | | 0 N/A N/A 38747 G /usr/bin/clash-verge 2MiB | +-----------------------------------------------------------------------------------------+ 6. AI部署框架 模型只是一堆参数，需要通过推理工具来运行，推理工具将模型参数加载到显存中，并依据输入的文字生成输出。\n我们接下来要完成:\n大模型框架部署(推理工具)，以Ollama为例； 模型部署，以Qwen32-14B为例； 前端接入，以CherryStudio为例； 7. 安装ollama 登陆ollama官网，发现官网直接给出一行命令，该命令自动下载并安装ollama：\n1 curl -fsSL https://ollama.com/install.sh | sh 该命令会下载一个脚本，该脚本使用curl命令下载ollama安装文件，然后并执行安装文件，但是这个curl始终不能连接网络，所以只能手动下载安装文件：\n第一步： 下载安装脚本 1 curl -fsSL https://ollama.com/install.sh -o ollama_install.sh # 下载安装脚本 第二步： 从安装脚本查找下载链接 在打开这个脚本搜索https://ollama.com/download/ollama-linux-，找到类似如下代码： 1 2 3 4 status \u0026#34;Downloading Linux ${ARCH} bundle\u0026#34; curl --fail --show-error --location --progress-bar \\ \u0026#34;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026#34; | \\ $SUDO tar -xzf - -C \u0026#34;$OLLAMA_INSTALL_DIR\u0026#34; 这段代码就是下载ollama安装文件的代码，并解压放到$OLLAMA_INSTALL_DIR目录下，就是usr/local/目录，至于下载链接，添加echo \u0026quot;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026quot;命令，然后运行脚本，打印出来的链接就是了。\n下载安装文件\n复制链接直接到浏览器中下载，并将下载好的压缩包保存到和安装脚本相同目录下。 1 2 3 zcli@fedora:~$ ls -lh | grep ollama -rwxrwxrwx. 1 zcli zcli 13K 5月18日 21:11 ollama_install.sh -rw-r--r--. 1 zcli zcli 1.6G 5月18日 21:04 ollama-linux-amd64.tgz 修改安装脚本\n定位到第二步中给出的代码： 1 2 3 4 status \u0026#34;Downloading Linux ${ARCH} bundle\u0026#34; curl --fail --show-error --location --progress-bar \\ \u0026#34;https://ollama.com/download/ollama-linux-${ARCH}.tgz${VER_PARAM}\u0026#34; | \\ $SUDO tar -xzf - -C \u0026#34;$OLLAMA_INSTALL_DIR\u0026#34; 修改为：\n1 2 status \u0026#34;Downloading Linux ${ARCH} bundle\u0026#34; $SUDO tar -xzf ollama-linux-amd64.tgz -C \u0026#34;$OLLAMA_INSTALL_DIR\u0026#34; 也就是不curl了，直接解压到指定目录。\n执行安装脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 zcli@fedora:~$ ./ollama_install.sh \u0026gt;\u0026gt;\u0026gt; Cleaning up old version at /usr/local/lib/ollama [sudo] zcli 的密码： \u0026gt;\u0026gt;\u0026gt; Installing ollama to /usr/local \u0026gt;\u0026gt;\u0026gt; Downloading Linux amd64 bundle \u0026gt;\u0026gt;\u0026gt; Creating ollama user... \u0026gt;\u0026gt;\u0026gt; Adding ollama user to render group... \u0026gt;\u0026gt;\u0026gt; Adding ollama user to video group... \u0026gt;\u0026gt;\u0026gt; Adding current user to ollama group... \u0026gt;\u0026gt;\u0026gt; Creating ollama systemd service... \u0026gt;\u0026gt;\u0026gt; Enabling and starting ollama service... Created symlink \u0026#39;/etc/systemd/system/default.target.wants/ollama.service\u0026#39; → \u0026#39;/etc/systemd/system/ollama.service\u0026#39;. \u0026gt;\u0026gt;\u0026gt; NVIDIA GPU installed. OK安装好了，但是注意了，在linux上，这个ollama是一个linux服务，安装后就运行起来了，如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 zcli@fedora:~$ sudo systemctl status ollama.service ● ollama.service - Ollama Service Loaded: loaded (/etc/systemd/system/ollama.service; enabled; preset: disabled) Drop-In: /usr/lib/systemd/system/service.d └─10-timeout-abort.conf, 50-keep-warm.conf Active: active (running) since Sun 2025-05-18 23:03:56 CST; 1min 31s ago Invocation: 2dbc0a03db1c4a08a17829fa4039bf63 Main PID: 43831 (ollama) Tasks: 13 (limit: 37474) Memory: 24.5M (peak: 40.9M) CPU: 248ms CGroup: /system.slice/ollama.service └─43831 /usr/local/bin/ollama serve 8. AI 模型部署 因为Ollama服务已经启动了，所以就不必再次运行ollama serve命令了。直接开run(如果还没有下载就会先下载，等待即可)：\n1 2 3 4 5 6 7 8 9 10 11 zcli@fedora:~$ ollama run qwen3:14b pulling manifest pulling a8cc1361f314: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 9.3 GB pulling eb4402837c78: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 1.5 KB pulling d18a5cc71b84: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 11 KB pulling cff3f395ef37: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 120 B pulling 78b3b822087d: 100% ▕██████████████████████████████████████████████████████████████████████████████████████████████▏ 488 B verifying sha256 digest writing manifest success \u0026gt;\u0026gt;\u0026gt; Send a message (/? for help) 好了，可以开始提问了，按照惯例先Hello Word:\n1 2 3 4 5 6 7 8 9 10 \u0026gt;\u0026gt;\u0026gt; 你好呀！ \u0026lt;think\u0026gt; 好的，用户发来“你好呀！”，我需要友好回应。首先，要保持亲切，用表情符号增加温度。然后，可以询问用户是否需要帮助，但不要显得太正式。可能用户只是打招呼， 所以简单回应即可，留出空间让用户继续交流。注意用词口语化，避免复杂句子。检查有没有拼写错误，确保回复自然。最后，保持开放态度，让用户知道我随时准备帮助他 们。 \u0026lt;/think\u0026gt; 你好呀！😊 很高兴见到你！今天过得怎么样呀？需要我帮忙做点什么吗？ \u0026gt;\u0026gt;\u0026gt; Send a message (/? for help) 此时的显存占用：11490MiB / 16311MiB，啊，这个，嗯..，刚刚好。\n提示：\nollama run qwen3:14b会从Ollama服务拉取模型，国内网络可能不太行，可以使用ollama run modelscope.cn/models/Qwen/Qwen3-14B。\n--verbose参数： 显示推理过程的耗时情况\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 zcli@fedora:~$ ollama run qwen3:14b --verbose \u0026gt;\u0026gt;\u0026gt; 西红柿怎么吃？ \u0026lt;think\u0026gt; 嗯，用户问的是“西红柿怎么吃？”，这个问题看起来挺简单的，但其实可能需要更深入的思考。首先，我得考虑用户可能的背景。他们可能是刚开始接触西红柿，或者想找 一些新的吃法。也可能他们之前吃过，但想尝试更多不同的做法。 ...... ...... # 这个就略了吧 \u0026lt;/think\u0026gt; 西红柿（番茄）是一种非常百搭的食材，既可以直接生吃，也可以通过多种烹饪方式制作成美味佳肴。以下是常见的吃法和一些创意做法，供你参考： ...... ...... # 这个也略吧 根据你的口味和需求，可以灵活选择以上吃法！如果需要具体菜谱或步骤，也可以告诉我哦 😊 # 下面的输出是重点 total duration: 33.622874783s # 总耗时33.6秒 load duration: 9.67421ms # 模型加载耗时9.67ms prompt eval count: 12 token(s) # 输入提示（prompt）的 token 数量，输入提示词被分词为 12 个 token。 prompt eval duration: 25.738437ms # 处理这 12 个 token 的提示词用了约 25.7 毫秒。 prompt eval rate: 466.23 tokens/s # 处理输入提示的速度（token/s），默认启用 enable_thinking=True（思考模式）。 eval count: 1278 token(s) # 模型生成输出的 token 总数。 eval duration: 33.587006893s # 生成输出的总耗时，占总耗时的 99.9%（total duration 的 33.62 秒）。说明生成阶段是性能瓶颈。。 eval rate: 38.05 tokens/s # 生成输出的速度（token/s），生成速度较慢（38 tokens/s），这与 14B 参数量的 Dense 模型特性一致， # Qwen3 的 MoE 模型（如 Qwen3-30B-A3B）通过激活部分参数（30B 总参数，仅激活 3B）实现更高的生成速度。 模型文件位于目录：/usr/share/ollama下。\n9. 前端接入 Ollama默认是在11434端口提供服务。明白了这个就可以到www.cherry-ai.com下载Cherry Studio了。\n安装好后，选择『设置』，然后在『设置』中选择『Ollama』：\n点击『添加』，然后填写“模型ID”，“模型名称”，“分组名称”，这些信息通过ollama list命令获取，注意了，这里的“模型ID”是ollama list命令输出的“NAME”，而不是ID,然后点击右上角的“检测”，提示“连接成功”就OK了，至于API密钥，随便填个什么就行，最后将默认助手的模型设置为我们刚刚添加的模型就可以使用了。\n10. 效果展示 以上文提到的西红柿问题为例，我们让qwen3-14b自己评价自己性能表现：\n","date":"2025-05-18T23:17:13+08:00","image":"https://zuoco.github.io/p/qwen3-14b%E9%83%A8%E7%BD%B2/AAA_hu_ddee986440f9159a.jpg","permalink":"https://zuoco.github.io/p/qwen3-14b%E9%83%A8%E7%BD%B2/","title":"Qwen3-14b部署"},{"content":"1. EPOLL介绍 EPOLL是Linux特有的I/O复用函数，它把用户关心的“文件描述符”放在内核里面一个事件表中，也就是说EPOLL需要一个“文件描述符”来标识内核中的这个事件表。另外EPOLL有两种工作模式：水平触发(Level Triggered，LT)和边缘触发(Edge Triggered，ET)，LT模式是EPOLL默认的工作模式，EPOLL和异步，非阻塞结合使用。\n2. EPOLL使用 2.1. 创建EPOLL对象 1 2 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_create(int size); // size参数没有意义。 返回一个文件描述符，代表内核事件表。\n2.2. 操作内核事件表 1 2 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); //成功返回0，失败返回-1，并设置errno。 epfd：内核事件表文件描述符。\nop：操作类型。\nfd：要操作的文件描述符。\nevent：指向 epoll_event 结构体的指针，用于指定要添加、修改或删除的事件。\n其中，op(操作类型)有三种：\nEPOLL_CTL_ADD：往内核事件表中添加事件。 EPOLL_CTL_MOD：修改事件。 EPOLL_CTL_DEL：删除事件。 其中，event(关心的事件)的类型是struct epoll_event，结构体定义如下：\n1 2 3 4 struct epoll_event { __uint32_t events; // 事件 epoll_data_t data; // 事件携带的用户数据 } events 是一个位图，有EPOLLIN、EPOLLOUT、EPOLLET、EPOLLONESHOT。\ndata 是epoll_data_t类型，它是一个联合体，定义如下：\n1 2 3 4 5 6 typedef union epoll_data { void *ptr; int fd; uint32_t u32; uint64_t u64; } epoll_data_t; 由于这是一个联合体，所以这四个成员，我们只能使用其中的一个。\n2.3. 等待事件 1 2 #include \u0026lt;sys/epoll.h\u0026gt; int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout); epoll_wait在一段超时时间内，等待一组文件描述符上的事件，返回就绪的文件描述符的数量。\ntimeout: 参数指定等待的时间，单位是毫秒。如果timeout为-1，则表示无限等待。 maxevents: 参数指定最多等待的事件数，必须大于0。 epoll_wait检测到事件，就会将所有的就绪事件从内核事件表拷贝到events数组中，并返回就绪事件的数量，也就是说event中的事件都是就绪的。\n3. ET和LT模式对比 对于Socket读事件，只要Socket上的数据没有读完，就会一直触发EPOLL事件，而对于ET模式，Socket上每来一次数据就会触发一次EPOLLIN事件，如果上一次触发后，未将 socket 上的数据读完，也不会再触发，除非再新来一次数据。对于 socket 写事件，如果 socket 的 TCP 窗口一直不饱和，会一直触发 EPOLLOUT 事件；而对于边缘模式，只会触发一次，除非 TCP 窗口由不饱和变成饱和再一次变成不饱和，才会再次触发 EPOLLOUT事件。根据以上分析来看，如果采用ET模式就必须在收到事件后一次性将数据读取完，但如果采用默认模式，就可以根据业务每次收取固定的字节数，多次收取，显然相对于默认的LT模式，ET模式能够减少同一个事件被触发的次数，效率比LT模式高。\n3.1. 问题 多线程场景下，我们使用ET模式监听一个Socket上的读事件，当数据到达时触发EPOLLIN事件，我们在一个独立线程(或进程)中读取该Socket上的数据，但是我们还没有读取完，该Socket又有新数据到达，此时另一个线程(或进程)被唤醒来读取该Socket上的数据，那么就有两个线程(进程)同时操作同一个Socket，这样好吗，这样不好，但是如何解决呢？此时就该EPOLLONESHOT出场了。\n4. EPOLLONESHOT事件 显然，一次性事件，就是触发以后，需要手动重新注册，给文件描述符注册EPOLLONESHOT事件，就可以保证同一时间只有一个人在使用。\n1 2 3 4 5 6 7 8 // 重新注册EPOLLONESHOT事件 void reset_oneshot(int epollfd, int fd) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN | EPOLLET | EPOLLONESHOT; epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, \u0026amp;event); } 注意： listening socket是不能使用EPOLLONESHOT的，否则后续的客户段连接请求就不会再触发listening socket的EPOLLIN事件了。\n5. 其他小代码 1. 将文件描述符设置为非阻塞\n1 2 3 4 5 6 7 int setnonblocking(int fd) { int old_option = fcntl(fd, F_GETFL); int new_option = old_option | O_NONBLOCK; fcntl(fd, F_SETFL, new_option); return old_option; } 2. 事件注册\n1 2 3 4 5 6 7 8 9 10 11 12 void addfd(int epollfd, int fd, bool enable_et) { epoll_event event; event.data.fd = fd; event.events = EPOLLIN; if(enable_et) { event.events |= EPOLLET; //启用ET模式 } epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, \u0026amp;event); setnonblocking(fd); } 3. 判断数据是否读取完了\n1 2 3 4 5 // 非阻塞模式 if ((errno == EAGAIN) || (errno == EWOULDBLOCK)) { // 数据读取完了 } ","date":"2025-05-12T20:16:48+08:00","permalink":"https://zuoco.github.io/p/epoll%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%94%A8%E6%B3%95/","title":"EPOLL系统调用用法"},{"content":"1. BootLoader Bootloader是操作系统的“引导程序”以及“引导管理程序”，操作系统的启动流程可以简单理解为：\n[上电] \u0026ndash;\u0026gt; [UEFI] \u0026ndash;\u0026gt; [bootloader] \u0026ndash;\u0026gt; [内核] 。\n显然，Bootloader的作用就是将内核加载到内存中，然后由于内核来加载操作系统的其他组件/服务，如文件系统，文件管理器，图形界面等。在linux生态中，常见的Bootloader有两种，Grub(用于X86架构)，U-Boot(用于ARM架构)。其中引导就是进行一些硬件的检测、初始化的任务，然后将内核加载到内存中来启动内核，引导管理就是当有多个内核时，在屏幕上显示一个菜单让用户选择要启动的哪个内核。 2. Grub grub程序保存在那里？\ngrub程序保存在EFI分区中，EFI分区挂在于位于/boot/efi目录下。\ngrub配置文件保存在那里？\n/boot/grub/grub.cfg文件，定义了grub是如何引导内核的。 /etc/default/grub文件，定义grub全局行为和启动参数，然后生成/boot/grub/grub.cfg文件，下面讲解以下该配置文件的内容： 1 2 3 4 5 6 7 8 9 GRUB_TIMEOUT=5 # 启动菜单的超时时间，超时后启动默认内核,-1表示无限等待。 GRUB_TIMEOUT_STYLE=menu # 启动菜单的样式，menu表示菜单样式，hidden表示隐藏菜单。 GRUB_DISTRIBUTOR=\u0026#34;$(sed \u0026#39;s, release .*$,,g\u0026#39; /etc/system-release)\u0026#34; # 动态提取发行版名称 GRUB_DEFAULT=saved # 默认启动项由上一次保存的选择决定 GRUB_DISABLE_SUBMENU=true # 禁用子菜单，所有内核和启动项直接显示在主菜单中。若设为 false，旧内核会折叠到“Advanced options”子菜单下。 GRUB_TERMINAL_OUTPUT=\u0026#34;console\u0026#34; # 强制GRUB仅使用文本控制台输出，禁用图形化终端（如gfxterm）。 GRUB_CMDLINE_LINUX=\u0026#34;rhgb quiet\u0026#34; # rhgb：启用Plymouth图形启动动画（常见于RHEL/CentOS/Fedora）。quiet：隐藏内核启动日志，仅显示简要信息。 GRUB_DISABLE_RECOVERY=\u0026#34;true\u0026#34; # 禁止恢复模式（Recovery Mode）的启动项。 GRUB_ENABLE_BLSCFG=true # 启用 Boot Loader Specification (BLS) 配置，取代传统的grub.cfg生成方式。 3. U-Boot XIP设备\n非XIP设备中存储的代码需要从存储设备中加载到内存中，然后才能执行，而XIP存储设备中的代码可以直接执行，XIP设备有SRAM、BROM等等，非XIP设备有EMMC、NANDFLASH、SD卡等等。 ARM-Linux启动流程\nU-Boot一般分为两个阶段，uboot-SPL和uboo-proper，CPU上电首先执行BROM中的程序(由芯片厂写入)，该程序会根据芯片的引脚电平或者寄存器配置确定启动模式(从那个设备启动系统)，例如系统安装在SD卡，BROM中的程序会初始化SD卡，然后拷贝uboot-spl到SRAM中，开始执行uboot-spl中的程序，uboot-spl程序会初始化LDDR内存、pll、gpio等等硬件，然后从SD卡中加载uboot-proper到LDDR中，并跳转到程序的入口地址执行uboot-proper程序。uboot还会初始化一些其他设备，例如网卡等，然后从SD卡中加载内核文件。\n参考:\nhttps://linux-sunxi.org/Bootable_SD_card#SD_Card_Layout 4. 修改Grub配置 GRUB配置文件： /boot/grub2/grub.cfg，但是该配置文件是生成的，不可直接手动修改，我们通过修改/etc/default/grub文件和/etc/grub.d/目录下的配置文件生成的。\n4.1. Fedora系统 修改/etc/default/grub文件，然后执行sudo grub2-mkconfig -o /boot/grub2/grub.cfg命令来生成新的/boot/grub2/grub.cfg文件。\n4.2. Debian系统 修改/etc/default/grub文件，然后执行sudo update-grub命令来生成新的/boot/grub/grub.cfg文件。\n5. 查看Grub配置信息 5.1. Fedora系统 5.1.1. grubby命令 查看默认引导项 1 sudo grubby --info=DEFAULT 列出所有引导项 1 sudo grubby --info=ALL 列出所有引导项的索引 1 sudo grubby --info=0 # 0是引导项的索引，使用sudo grubby --info=ALL命令查看 5.2. Debian系统 使用grep命令查看即可。\n","date":"2025-05-10T20:46:50+08:00","permalink":"https://zuoco.github.io/p/bootloader/","title":"BootLoader"},{"content":"1. 内核中的Makefile、Kconfig、config Makefile：编译源文件的方法。 Kconfig：内核的配置菜单。 .config：根据配置菜单生成的配置，根据该配置编译内核。 2. Makefile 内核中的Makefile中有三种编译规则：\n编译进入内核。 1 obj-y += xxx/ # 进入子Makefile 1 obj-y += xxx.o 根据.config决定是否编译进入内核。 1 obj-$(CONFIG_XXX) += xxx/ # 进入子Makefile 1 obj-$(CONFIG_XXX) += xxx.o 编译为模块 执行make modules时被编译 1 obj-m += xxx.o 3. Kconfig 执行make menuconfig时会展示一个菜单，就是Kconfig的功劳。\nlinux-6.0目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # SPDX-License-Identifier: GPL-2.0 # # For a description of the syntax of this configuration file, # see Documentation/kbuild/kconfig-language.rst. # mainmenu \u0026#34;Linux/$(ARCH) $(KERNELVERSION) Kernel Configuration\u0026#34; source \u0026#34;scripts/Kconfig.include\u0026#34; # ...... 表示省略一堆代码 # ...... source \u0026#34;drivers/Kconfig\u0026#34; # ...... # ...... source \u0026#34;Documentation/Kconfig\u0026#34; linux-6.0/drivers目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 # SPDX-License-Identifier: GPL-2.0 menu \u0026#34;Device Drivers\u0026#34; # Keep I/O buses first # ...... # ...... source \u0026#34;drivers/video/Kconfig\u0026#34; ## ...... ## ...... linux-6.0/drivers/video目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # SPDX-License-Identifier: GPL-2.0-only # # Video configuration # menu \u0026#34;Graphics support\u0026#34; # ...... # ...... source \u0026#34;drivers/gpu/drm/Kconfig\u0026#34; # ...... # ...... endmenu linux-6.0/drivers/gpu/drm目录下的Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # ...... # ...... source \u0026#34;drivers/gpu/drm/display/Kconfig\u0026#34; # ...... #...... source \u0026#34;drivers/gpu/drm/amd/amdgpu/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/nouveau/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/i915/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/rockchip/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/qxl/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/virtio/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/xen/Kconfig\u0026#34; source \u0026#34;drivers/gpu/drm/vboxvideo/Kconfig\u0026#34; drivers/gpu/drm/qxl/Kconfig: 1 2 3 4 5 6 7 8 9 10 11 12 # SPDX-License-Identifier: GPL-2.0-only config DRM_QXL tristate \u0026#34;QXL virtual GPU\u0026#34; depends on DRM \u0026amp;\u0026amp; PCI \u0026amp;\u0026amp; MMU select DRM_KMS_HELPER select DRM_TTM select DRM_TTM_HELPER select CRC32 help QXL virtual GPU for Spice virtualization desktop integration. Do not enable this driver unless your distro ships a corresponding X.org QXL driver that can handle kernel modesetting. 下面详细分析一下这个Kconfig文件的内。\n3.1. Kconfig文件内容分析 第1行\n1 # SPDX-License-Identifier: GPL-2.0-only 声明此文件的许可证为 GPL-2.0-only（GNU通用公共许可证第2版，仅限此版本）。这是一个开源许可证，表示任何人可以自由使用、修改和分发此代码，但必须保留相同的许可证条款。only 表示只能使用 GPL-2.0，不能升级到更新的版本（如 GPL-3.0）。 第2行\n1 config DRM_QXL # 使用config关键字定义一个选项 定义了一个选项，省略了CONFIG_，全称是CONFIG_DRM_QXL，在对应的Makefile文件中使用。如下：\ndrivers/gpu/drm/Makefile\n1 obj-$(CONFIG_DRM_QXL) += qxl/ drivers/gpu/drm/qxl/Makefile\n1 obj-$(CONFIG_DRM_QXL)+= qxl.o 第3行\n1 tristate \u0026#34;QXL virtual GPU\u0026#34; 声明 DRM_QXL 是一个 三态选项（tristate），可选值为 Y（内置）、M（模块）、N（禁用），并为其添加描述文本 \u0026ldquo;QXL virtual GPU\u0026rdquo;。 Y（Yes）：驱动直接编译进内核。\nM（Module）：驱动编译为可加载的内核模块（.ko 文件）。\nN（No）：不编译此驱动。\n第4行\n1 depends on DRM \u0026amp;\u0026amp; PCI \u0026amp;\u0026amp; MMU 指定 DRM_QXL 的依赖条件，只有当 DRM、PCI 和 MMU 都被启用时，DRM_QXL 才能被选择。\n第5~8行\n1 2 3 4 select DRM_KMS_HELPER select DRM_TTM select DRM_TTM_HELPER select CRC32 反向依赖关系，该选项选中时，同时选中select后面定义的那一项。。\n第9~13行\n1 2 3 4 help QXL virtual GPU for Spice virtualization desktop integration. Do not enable this driver unless your distro ships a corresponding X.org QXL driver that can handle kernel modesetting. 为 DRM_QXL 提供帮助信息，在配置工具中按 ? 可以查看。\n4. .config文件 使用make menuconfig生成的配置文件。\n5. make menuconfig 运行make menuconfig命令，会显示一个配置菜单:\n使用“上”“下”方向键选择选项，使用“空格”键选择或取消选择选项，使用“Enter”键进入子菜单。使用“左”“右”保存、后退、加载已有的.config文件。配置完后保存为.config文件，然后运行make命令进行开始编译。\n","date":"2025-05-10T18:06:49+08:00","image":"https://zuoco.github.io/p/linux%E5%86%85%E6%A0%B8%E6%9E%84%E5%BB%BA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/AAA_hu_d486ea4199ce7f81.jpg","permalink":"https://zuoco.github.io/p/linux%E5%86%85%E6%A0%B8%E6%9E%84%E5%BB%BA%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA/","title":"Linux内核构建、内核模块构建"},{"content":"iBMC服务器管理软件 iBMC智能管理系统（Intelligent Baseboard Management Controller，以下简称iBMC）是面向服务器全生命周期的服务器嵌入式管理系统。提供硬件状态监控、部署、节能、安全等系列管理工具，标准化接口构建服务器管理更加完善的生态系统。\niBMC登陆界面 iBMC管理界面 监控与故障管理 (FDM) 故障诊断与管理（FDM）是iBMC一系列诊断技术和工具的总称，FDM对服务器各类部件进行全面的监控，实现服务器关键部件的深度故障诊断和故障预测机制。\n智慧能耗管理 (DEMT) 动态能耗管理技术（DEMT）是一组根据CPU负载、环境温度等多种输入参数，动态实时智能调节各部件的功耗的技术集合，通过动态能耗管理技术和休眠技术，使设备节能管理更加高效。\n“零”接触运维 iBMC提供KVM，SOL虚拟媒体，Web接入等多种远程管理方式，支持配置、升级、部署能力，实现“零”接触运维，方便运维人员随时随地接入服务器实施运维管理。\n","date":"2025-05-08T21:01:19+08:00","image":"https://zuoco.github.io/p/ibmc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/AAA_hu_b61cde5c6187d9b1.jpg","permalink":"https://zuoco.github.io/p/ibmc%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6/","title":"iBMC服务器管理软件"},{"content":"1. 基本概念 仓库（Repository）：一个Git仓库是一个包含所有版本控制文件和历史记录的目录。\n本地仓库（Local Repository）：在你的本地计算机上的仓库。 远程仓库（Remote Repository）：托管在服务器上的仓库，通常是GitHub、GitLab等。 工作区（Workspace）: 你在本地计算机上的项目目录，包含了所有的文件和目录。 暂存区（Stage）: 用于暂存即将提交的文件，添加到暂存区的文件会被git跟踪。 主分支：新建一个仓库会分配一个默认主分支，早期为“master”，现在为“main”。 head: 指向当前工作的分支的最新提交，每次提交都会更新head，保持head指向最新的提交。\n2. Git的配置 全局配置：\n1 2 3 4 5 6 7 git config --global user.name \u0026#34;Your Name\u0026#34; git config --global user.email \u0026#34;your_email@example.com\u0026#34; 仓库配置： ```bash # 在仓库目录下执行以下命令： git config --local user.name \u0026#34;Your Name\u0026#34; git config --local user.email \u0026#34;your_email@example.com\u0026#34; 保存在当前仓库下.git/config文件中，仓库配置会覆盖全局配置。\n查看配置：\n1 git config --list 3. 创建本地仓库 1 git init 4. 查看仓库状态 1 git status 5. 添加文件到暂存区 1 2 git add \u0026lt;file\u0026gt; git add . # 添加所有文件 6. 提交到本地仓库 1 git commit -m \u0026#34;提交信息\u0026#34; git会为每一个提交创建一条版本历史记录，包含：\ncommit id: 40位字符串，表示一个唯一的提交ID，用于标识提交，在命令中使用前6位即可。 commit message: 提交信息，用于描述本次提交的内容。 快照： 完整版本文件，以对象树的形式存储在.git/objects目录下。 commit还有其他用法：\n1 2 # 使用一次新的提交，替代上一次提交，会修改commit id git commit --amend -m \u0026#34;修改提交信息\u0026#34; 1 2 # 提交指定文件 git commit filename 7. 提交日志 1 git log 会列出所有提交的信息，包括commit id、commit message、作者、提交时间等。\n8. 查询文件变更 1 git diff 可以查看工作区和暂存区之间的差异，删除的行会以删除符号（\u0026mdash;）标记，新增的行会以新增符号（+++）标记。\nChanges to be committed: 已经git add的文件，但是还没有git commit的文件。 Changes not staged for commit: 还没有git add的文件。 Unmodified files: 没有被git跟踪的文件。\n9. 关联远程仓库 关联远程仓库： 情况1：已创建本地仓库\n1 git remote add origin \u0026lt;repository_url\u0026gt; 情况2：未创建本地仓库\n1 2 3 4 5 6 7 8 9 # 先创建仓库 git init # 关联远程仓库 git remote add origin \u0026lt;repository_url\u0026gt; # 提交到本地仓库 git add . git commit -m \u0026#34;xxxxxx\u0026#34; # 推送本地仓库到远程仓库 git push -u origin main 10. 克隆远程仓库 1 git clone \u0026lt;repository_url\u0026gt; 11. 查看关联的远程仓库 1 git remote -v 12. 同步仓库 1 2 3 git pull \u0026lt;远程仓库名\u0026gt; \u0026lt;远程仓库分支名\u0026gt; # 获取远程仓库的最新提交，并与本地仓库合并。 # git pull origin main # git pull 默认从当前仓库远程仓库和分支拉取更新。 13. 推送到远程仓库 1 2 3 # origin就是使用“git remote add origin \u0026lt;仓库地址\u0026gt;”所添加的远程仓库。 git push -u origin main # 第一次推送时，需要使用-u设置上游分支，表示将当本地分支与远程分支关联起来。 git push # 推送到默认的远程仓库和分支。 1 git push origin \u0026lt;本地分支名\u0026gt;:\u0026lt;远程分支名\u0026gt; # 推送指定分支到远程仓库的指定分支。 1 git push --all origin # 将本地所有分支推送到远程仓库。 14. git分支 14.1. 查看分支 1 2 git branch # 查看本地分支 git branch -a # 查看所有分支，包括本地和远程分支 14.2. 创建分支 1 git branch \u0026lt;branch_name\u0026gt; 14.3. 切换到指定分支 1 2 git checkout \u0026lt;branch_name\u0026gt; git switch \u0026lt;branch_name\u0026gt; 14.4. 分支合并 1 git merge \u0026lt;branch_name\u0026gt; # 将指定分支合并到当前分支 例如：\n当前有两个分支：main和dev，现在需要将dev分支合并到main分支上，执行以下命令：\n1 2 git switch main # 切换到main分支 git merge dev # 将dev分支合并到main分支上 15. git冲突 合并时发生冲突：* CONFLICT (content): Merge conflict in XXXXXX Automatic merge failed; fix conflicts and then commit the result.\n发生冲突时:\n使用git status命令查看冲突文件，并打开冲突文件: 1 both modified: xxxxxx # 两个分支都修改了xxxxxx文件 打开xxxxxx文件： 1 2 3 4 5 \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; HEAD 这里是原本的代码； ======= 这里是dev分支修改的代码； \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; dev 阅读代码逻辑，手动修改代码，并保存文件，然后重新add以及commit就可以了，不需要重新merge，已经merge过了。\n16. 删除分支 合并分支后，删除分支：\n1 2 3 4 git branch -d \u0026lt;branch_name\u0026gt; # 删除本地分支 git push origin --delete \u0026lt;branch_name\u0026gt; # 删除远程分支 git branch -D \u0026lt;branch_name\u0026gt; # 强制删除分支 17. 标签 用来标注项目中的特定版本，例如正式发布版本，如v1.0.0。\n17.1. 查看标签 1 git tag # 查看所有标签 1 git show \u0026lt;tag_name\u0026gt; # 查看指定标签详细信息 17.2. 创建标签 轻量标签：\n1 git tag \u0026lt;tag_name\u0026gt; # 指向当前最新的提交 附注标签：\n1 git tag -a \u0026lt;tag_name\u0026gt; -m \u0026#34;tag_message\u0026#34; # 指向当前最新的提交 给过去的提交打标签：\n1 git tag -a \u0026lt;标签名\u0026gt; \u0026lt;commit_id\u0026gt; -m \u0026#34;tag_message\u0026#34; # commit_id使用前6位即可 17.3. 推送标签 推送单个标签：\n1 git push origin \u0026lt;tag_name\u0026gt; 推送所有标签：\n1 git push origin --tags 17.4. 删除标签 删除本地标签：\n1 git tag -d \u0026lt;tag_name\u0026gt; 删除本地标签后，元远程标签还在，这时需要使用以下命令删除远程标签：\n1 git push origin --delete \u0026lt;tag_name\u0026gt; 18. 撤销修改 18.1. 还没有git add，想恢复到最后一次提交 1 git reset checkout -- xxxxxx.cpp 18.2. 已经git add，想恢复到最后一次提交 1 2 git reset HEAD xxxxxx.cpp # 将文件从暂存区移除，但文件的修改仍然保存在文件中 git checkout -- xxxxxx.cpp # 将文件恢复到最后一次提交的状态 18.3. 已经git commit，想回退到某个提交 回退本地提交：\n1 2 3 git reset --soft HEAD~1 # 会退提交到当前分支的上一次提交，但是代码依然保留在暂存区，以及工作区。 # HEAD~1表示当前最新提交的上一个提交。 git reset --mixed HEAD~1 # 会退提交，删除暂存区对应代码，但工作区依然保留。 # 默认模式 git reset --hard HEAD~1 # 会退提交，删除暂存区对应代码，删除工作区对应代码。 也可以使用commit id替代HEAD~1。\n会退远程提交： 创建一次新的commit，覆盖指定的一次commit。\n1 2 3 git revert commit_id git commit -m \u0026#34;Revert commit_id\u0026#34; # 再次提交 git push origin master 19. 提交的合并 Cherry-pick 将某个分支上的单个或多个提交（commit）“复制”到当前分支,合并提交，而不是合并整个分支。\n1 2 3 4 5 # 切换到目标分支 git checkout \u0026lt;目标分支名\u0026gt; # 应用指定提交（\u0026lt;commit-hash\u0026gt; 是源分支提交的哈希值） git cherry-pick \u0026lt;commit-hash\u0026gt; 1 2 3 4 5 # 依次应用多个提交 git cherry-pick \u0026lt;commit1\u0026gt; \u0026lt;commit2\u0026gt; \u0026lt;commit3\u0026gt; # 或使用区间语法（左开右闭） git cherry-pick \u0026lt;start-commit\u0026gt;^..\u0026lt;end-commit\u0026gt; ","date":"2025-05-07T21:48:29+08:00","image":"https://zuoco.github.io/p/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/git_hu_5f7d6e0c84ead86c.jpg","permalink":"https://zuoco.github.io/p/git%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","title":"Git基本使用"},{"content":"1. 项目构建系统 2. 项目目录结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 deskflow-1.21.2/ ├── cmake/ ├── CMakeLists.txt ├── cspell.json ├── deploy/ ├── doc/ ├── src/ ├── LICENSE ├── LICENSES/ ├── README.md ├── REUSE.toml ├── SECURITY.md ├── sonar-project.properties ├── vcpkg-configuration.json └── vcpkg.json 下面大概介绍一下主要文件的用途：\n2.1. vcpkg.json和vcpkg-configuration.json vcpkg是一个C++包管理工具，vcpkg-configuration.json 和 vcpkg.json 协同工作。vcpkg.json 列出了项目所需的依赖包，而 vcpkg-configuration.json 则指定了从哪些地方获取这些包。当执行 vcpkg install 命令时，vcpkg 会先依据 vcpkg-configuration.json 配置的注册表，再按照 vcpkg.json 列出的依赖，去下载、编译并集成所需的包到项目中。\n2.2. sonar-project.properties 代码质量管理相关的文件。\n2.3. SECURITY.md 声明安全策略和漏洞管理流程。\n2.4. RESEUE.toml 统一管理Deskflow项目的版权归属和许可证声明，确保所有文件符合开源合规要求。\n2.5. LICENSE 统一管理Deskflow项目的版权归属和许可证声明，确保所有文件符合开源合规要求。\n2.6. cspell.json 拼写检查配置文件，用于定义 Deskflow 项目中允许的特定术语、技术词汇和专有名词，确保拼写检查工具（如 VS Code 的 Code Spell Checker）在扫描代码时 忽略合法词汇，同时标记拼写错误。\n2.7. 目录LICENSES 包含四种开源许可证文件，定义了项目各组件的合法使用、修改和分发规则。\n2.8. 目录src 包含源代码文件，包括主程序、工具类、配置文件等。\n2.9. 目录deploy 部署脚本,定义了在不同平台上的部署方法.\n2.10. cmake cmake模块,定义了cmake的配置文件,负责构建过程中的依赖检查.\n2.11. doc 文档,包括用户指南、开发指南等.\n3. 子目录src 1 2 3 4 5 src/ ├── apps/ ├── CMakeLists.txt ├── lib/ └── test/ 面对一个软件,我们可以将代码分为两部分: 架构层代码、业务层代码。 apps: 业务层代码，包含了具体的业务逻辑和功能实现。 lib: 架构层代码，包含了框架、工具类、配置文件等。 test: 测试代码，包含了单元测试、集成测试等。\n3.2. apps 1 2 3 4 5 6 7 8 apps/ ├── CMakeLists.txt ├── deskflow-client/ ├── deskflow-core/ ├── deskflow-daemon/ ├── deskflow-gui/ ├── deskflow-server/ └── res apps目录下就是业务层的代码了，通过第一节，我们知道，DeskFlow这个软件是一个“服务器－客户端”的模式，DeskFlow编译成功后有３个可执行文件: deskflow、deskflow-server、deskflow-client。 deskflow-server:\n就是服务端代码，也就运行在实际插入物理键盘鼠标的电脑上; deskflow-client: 就是客户端代码，和服务端相对; deskflow-core: deskflow就是deskflow-core程序，既是客户端也是服务端，运行是根据传入的命令行参数来判断是运行为服务端还是运行为客户端。 deskflow-gui: GUI代码，基于Qt。\n3.1. lib DeskFlow的底层逻辑，比如跨平台抽象层。\n","date":"2025-05-06T20:36:33+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC%E4%BA%8C%E8%8A%82-deskflow%E5%B7%A5%E7%A8%8B%E6%BA%90%E7%A0%81%E6%95%B4%E4%BD%93%E8%AE%A4%E8%AF%86/","title":"第二节 - DeskFlow工程源码整体认识"},{"content":"1. Deskflow介绍 在多台电脑上共享一套键鼠，支持Windows、Linux、MacOS，功能类似于一个基于软件的KVM切换器，在不同机器之间无缝切换。 本专题中，我们以1.21.2版本为例，介绍一下软件的功能，项目地址Deskflow。\n2. 功能 首次启动软件时，需要选择当前的电脑模式，是作为服务端还是客户端，界面如下： 接入物理键盘鼠标的就是服务端，其他电脑就是客户端。\n3. 软件配置 【Edit】\u0026ndash;\u0026gt;【Preferences】 有三项配置：Basics、APP、Enable TSL Encryption。\n1. Basics：\n阻止计算机休眠。 使用服务器键盘语言（该配置在客户端上使用），因为客户端和服务端键盘语言可能不一致，统一使用服务器键盘语言，这样就一致了。 反转鼠标滚轮滚动时页面滚动方向（该配置在客户端上使用），这算是一个个性化配置。 2. APP：\n应用启动时检查更新。 关闭应用窗口时，后台运行。 后台启动。 Tray Icon style，系统托盘图标样式。 3. Enable TSL Encryption：\n启用TSL加密，这是一个安全配置。 Network Address，配置网络地址，默认即可。 Logs，配置日志文件保存路径、日志级别。 服务端和客户端在这一层面的配置界面是一样的。\n4. 服务端 (1) 加载已有的配置文件，如果没有现成的配置文件，就点击【Configure Server】。\n(2) 配置服务器信息，界面如下： 【Computers】\n该项设置配置客户端与服务端的布局，中间的GEM12是服务器，服务器周围的格子用于放置客户端，通过拖动右上角的电脑图标来创建客户端PC，如下图所示： 双击创建的客户端PC，就可以配置客户端的信息了，如下图所示： 该页面中需要注意的是Fixes，部分按键在一些平台上不可用，可以通过Fixes来修复，例如在Linux系统上Scroll Lock键不可用。\n5. 键鼠在PC之间的切换逻辑 红框区域提供了两种切换方式：\n在两台PC之间的边界超过指定时间切换到对应的PC。 在指定的时间内，两次tap切换到对应的PC，这个没有好像有BUG，不起作用。 6. 客户端 客户端配置： 【3. 软件配置】\n客户端使用： 输入服务器IP或者服务器名称，然后点击连接。\n","date":"2025-05-06T20:36:33+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC%E4%B8%80%E8%8A%82-desklow%E5%88%9D%E6%AD%A5%E8%AE%A4%E8%AF%86/","title":"第一节 - Desklow初步认识"},{"content":"Qemu介绍 Qemu（Quick Emulator），一款开源的硬件虚拟化和仿真工具，Qemu本身可以运行在多种平台上（x86、ARM、RISC-V），并且能够模拟多种虚拟机。WMware、VirtualBox等虚拟化虚拟化平台只能运行在x86平台上，也只能模拟X86环境，而Qemu可以运行在多种平台，并且能够模拟多种虚拟机。 Qemu的系统模式和用户模式，系统模式就是模拟出一套硬件环境，在这个虚拟的硬件上安装操作系统，用户模式就是直接运行为另一个操作系统开发的程序。 qmu仓库 https://gitlab.com/qemu-project/qemu wiki https://wiki.qemu.org/Hosts/Linux\nAMD64平台编译Qemu 以Fedora42为例，编译Qemu。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 Build targets in project: 643 qemu 9.2.2 Build environment Build directory : /home/zcli/test/qemu-9.2.2/build Source path : /home/zcli/test/qemu-9.2.2 Download dependencies : YES Directories Build directory : /home/zcli/test/qemu-9.2.2/build Source path : /home/zcli/test/qemu-9.2.2 Download dependencies : YES Install prefix : /usr/local BIOS directory : share/qemu firmware path : share/qemu-firmware binary directory : /usr/local/bin library directory : /usr/local/lib64 module directory : lib64/qemu libexec directory : /usr/local/libexec include directory : /usr/local/include config directory : /usr/local/etc local state directory : /var/local Manual directory : /usr/local/share/man Doc directory : /usr/local/share/doc Host binaries python : /home/zcli/test/qemu-9.2.2/build/pyvenv/bin/python3 (version: 3.13) sphinx-build : NO gdb : /usr/bin/gdb iasl : NO genisoimage : Configurable features Documentation : NO system-mode emulation : YES user-mode emulation : NO block layer : YES Install blobs : YES module support : NO fuzzing support : NO Audio drivers : oss Trace backends : log D-Bus display : YES QOM debugging : YES Relocatable install : YES vhost-kernel support : YES vhost-net support : YES vhost-user support : YES vhost-user-crypto support : YES vhost-user-blk server support : YES vhost-vdpa support : YES build guest agent : YES Compilation host CPU : x86_64 host endianness : little C compiler : cc -m64 Host C compiler : cc -m64 C++ compiler : NO Objective-C compiler : NO Rust support : NO CFLAGS : -g -O2 QEMU_CFLAGS : -mcx16 -msse2 -D_GNU_SOURCE -D_FILE_OFFSET_BITS=64 -D_LARGEFILE_SOURCE -fno-strict-aliasing -fno-common -fwrapv -ftrivial-auto-var-init=zero -fzero-call-used-regs=used-gpr -fstack-protector-strong QEMU_LDFLAGS : -fstack-protector-strong -Wl,-z,relro -Wl,-z,now link-time optimization (LTO) : NO PIE : YES static build : NO malloc trim support : YES membarrier : NO debug graph lock : NO debug stack usage : NO mutex debugging : NO memory allocator : system avx2 optimization : YES avx512bw optimization : YES gcov : NO thread sanitizer : NO CFI support : NO strip binaries : NO sparse : NO mingw32 support : NO Cross compilers x86_64 : cc Targets and accelerators KVM support : YES HVF support : NO WHPX support : NO NVMM support : NO Xen support : NO Xen emulation : YES TCG support : YES TCG backend : native (x86_64) TCG plugins : YES TCG debug enabled : NO target list : x86_64-softmmu default devices : YES out of process emulation : YES vfio-user server : NO Block layer support coroutine backend : ucontext coroutine pool : YES Block whitelist (rw) : Block whitelist (ro) : Use block whitelist in tools : NO VirtFS (9P) support : YES replication support : YES bochs support : YES cloop support : YES dmg support : YES qcow v1 support : YES vdi support : YES vhdx support : YES vmdk support : YES vpc support : YES vvfat support : YES qed support : YES parallels support : YES FUSE exports : NO VDUSE block exports : YES Crypto TLS priority : NORMAL GNUTLS support : YES 3.8.9 GNUTLS crypto : YES libgcrypt : NO nettle : NO SM4 ALG support : NO SM3 ALG support : NO AF_ALG support : NO rng-none : NO Linux keyring : YES Linux keyutils : YES 1.6.3 User interface SDL support : NO SDL image support : NO GTK support : YES pixman : YES 0.44.2 VTE support : YES 0.80.1 PNG support : YES 1.6.44 VNC support : YES VNC SASL support : YES VNC JPEG support : YES 3.1.0 spice protocol support : YES 0.14.4 spice server support : YES 0.15.1 curses support : YES brlapi support : NO Graphics backends VirGL support : NO Rutabaga support : NO Audio backends OSS support : YES sndio support : NO ALSA support : NO PulseAudio support : NO PipeWire support : NO JACK support : NO Network backends AF_XDP support : NO slirp support : NO vde support : NO netmap support : NO l2tpv3 support : YES Dependencies libtasn1 : YES 4.20.0 PAM : NO iconv support : YES blkio support : NO curl support : NO Multipath support : NO Linux AIO support : NO Linux io_uring support : NO ATTR/XATTR support : YES RDMA support : NO fdt support : YES libcap-ng support : NO bpf support : NO rbd support : NO smartcard support : YES 2.8.1 U2F support : NO libusb : YES 1.0.28 usb net redir : YES 0.15.0 OpenGL support (epoxy) : YES 1.5.10 GBM : YES 25.0.4 libiscsi support : NO libnfs support : NO seccomp support : NO GlusterFS support : NO hv-balloon support : YES TPM support : YES libssh support : NO lzo support : NO snappy support : NO bzip2 support : YES lzfse support : NO zstd support : YES 1.5.7 Query Processing Library support: NO UADK Library support : NO qatzip support : NO NUMA host support : NO capstone : NO libpmem support : NO libdaxctl support : NO libcbor support : NO libudev : YES 257 FUSE lseek : NO selinux : YES 3.8 libdw : YES 0.192 Subprojects berkeley-softfloat-3 : YES berkeley-testfloat-3 : YES keycodemapdb : YES libvduse : YES libvhost-user : YES User defined options Native files : config-meson.cross docs : disabled plugins : true Found ninja-1.12.1 at /usr/bin/ninja Running postconf script \u0026#39;/home/zcli/test/qemu-9.2.2/build/pyvenv/bin/python3 /home/zcli/test/qemu-9.2.2/scripts/symlink-install-tree.py\u0026#39; Fedora42安装virt-manager virt-manager是一个图形化的虚拟机管理工具，它可以管理虚拟机的创建、启动、停止、删除等操作。安装virt-manager时会安装平台对应的Qemu组件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 zcli@fedora:~$ sudo yum install virt-manager.noarch 仓库更新和加载中: 仓库加载完成。 Package Arch Version Repository Size Installing: virt-manager noarch 5.0.0-2.fc42 fedora 3.5 MiB Installing dependencies: SDL2_image x86_64 2.8.8-1.fc42 fedora 209.7 KiB device-mapper-multipath-libs x86_64 0.10.0-5.fc42 fedora 873.7 KiB kf5-filesystem x86_64 5.116.0-4.fc42 fedora 1.4 KiB libblkio x86_64 1.5.0-2.fc41 fedora 664.2 KiB libburn x86_64 1.5.6-6.fc42 fedora 357.5 KiB libisoburn x86_64 1.5.6-7.fc42 fedora 1.1 MiB libisofs x86_64 1.5.6-6.fc42 fedora 508.3 KiB libnfs x86_64 6.0.2-2.fc42 fedora 518.1 KiB libvirt-ssh-proxy x86_64 11.0.0-1.fc42 fedora 19.9 KiB python3-libxml2 x86_64 2.12.10-1.fc42 fedora 1.2 MiB qemu-audio-alsa x86_64 2:9.2.3-1.fc42 updates 28.5 KiB qemu-audio-dbus x86_64 2:9.2.3-1.fc42 updates 268.0 KiB qemu-audio-jack x86_64 2:9.2.3-1.fc42 updates 19.9 KiB qemu-audio-oss x86_64 2:9.2.3-1.fc42 updates 19.7 KiB qemu-audio-pa x86_64 2:9.2.3-1.fc42 updates 27.8 KiB qemu-audio-pipewire x86_64 2:9.2.3-1.fc42 updates 44.6 KiB qemu-audio-sdl x86_64 2:9.2.3-1.fc42 updates 19.7 KiB qemu-audio-spice x86_64 2:9.2.3-1.fc42 updates 15.7 KiB qemu-block-blkio x86_64 2:9.2.3-1.fc42 updates 36.1 KiB qemu-block-curl x86_64 2:9.2.3-1.fc42 updates 32.2 KiB qemu-block-dmg x86_64 2:9.2.3-1.fc42 updates 11.2 KiB qemu-block-gluster x86_64 2:9.2.3-1.fc42 updates 31.5 KiB qemu-block-iscsi x86_64 2:9.2.3-1.fc42 updates 50.5 KiB qemu-block-nfs x86_64 2:9.2.3-1.fc42 updates 28.8 KiB qemu-block-rbd x86_64 2:9.2.3-1.fc42 updates 40.9 KiB qemu-block-ssh x86_64 2:9.2.3-1.fc42 updates 42.5 KiB qemu-char-baum x86_64 2:9.2.3-1.fc42 updates 19.5 KiB qemu-char-spice x86_64 2:9.2.3-1.fc42 updates 20.4 KiB qemu-device-display-qxl x86_64 2:9.2.3-1.fc42 updates 88.6 KiB qemu-device-display-vhost-user-gpu x86_64 2:9.2.3-1.fc42 updates 746.1 KiB qemu-device-display-virtio-gpu-ccw x86_64 2:9.2.3-1.fc42 updates 11.4 KiB qemu-device-display-virtio-gpu-gl x86_64 2:9.2.3-1.fc42 updates 46.3 KiB qemu-device-display-virtio-gpu-pci x86_64 2:9.2.3-1.fc42 updates 15.5 KiB qemu-device-display-virtio-gpu-pci-gl x86_64 2:9.2.3-1.fc42 updates 11.0 KiB qemu-device-display-virtio-gpu-pci-rutabaga x86_64 2:9.2.3-1.fc42 updates 11.2 KiB qemu-device-display-virtio-gpu-rutabaga x86_64 2:9.2.3-1.fc42 updates 38.3 KiB qemu-device-display-virtio-vga-gl x86_64 2:9.2.3-1.fc42 updates 11.2 KiB qemu-device-display-virtio-vga-rutabaga x86_64 2:9.2.3-1.fc42 updates 11.2 KiB qemu-device-usb-host x86_64 2:9.2.3-1.fc42 updates 48.8 KiB qemu-device-usb-redirect x86_64 2:9.2.3-1.fc42 updates 68.8 KiB qemu-device-usb-smartcard x86_64 2:9.2.3-1.fc42 updates 32.6 KiB qemu-kvm x86_64 2:9.2.3-1.fc42 updates 0.0 B qemu-pr-helper x86_64 2:9.2.3-1.fc42 updates 973.1 KiB qemu-system-x86 x86_64 2:9.2.3-1.fc42 updates 0.0 B qemu-ui-curses x86_64 2:9.2.3-1.fc42 updates 39.6 KiB qemu-ui-egl-headless x86_64 2:9.2.3-1.fc42 updates 15.5 KiB qemu-ui-gtk x86_64 2:9.2.3-1.fc42 updates 78.3 KiB qemu-ui-opengl x86_64 2:9.2.3-1.fc42 updates 36.3 KiB qemu-ui-sdl x86_64 2:9.2.3-1.fc42 updates 44.8 KiB qemu-ui-spice-app x86_64 2:9.2.3-1.fc42 updates 15.4 KiB qemu-ui-spice-core x86_64 2:9.2.3-1.fc42 updates 59.8 KiB rutabaga-gfx-ffi x86_64 0.1.3-3.fc42 fedora 607.3 KiB virglrenderer x86_64 1.1.0-2.fc42 fedora 1.1 MiB virt-manager-common noarch 5.0.0-2.fc42 fedora 6.2 MiB virtiofsd x86_64 1.13.0-2.fc42 fedora 2.5 MiB xorriso x86_64 1.5.6-7.fc42 fedora 341.6 KiB Installing weak dependencies: libvirt-daemon-kvm x86_64 11.0.0-1.fc42 fedora 0.0 B Transaction Summary: Installing: 58 packages ","date":"2025-05-05T23:36:36+08:00","image":"https://zuoco.github.io/p/qemu%E4%BB%8B%E7%BB%8D/AAA_hu_c1639a94b96af9d0.jpg","permalink":"https://zuoco.github.io/p/qemu%E4%BB%8B%E7%BB%8D/","title":"Qemu介绍"},{"content":"1. 什么是容器 就是一些标准库中设计好数据结构，使用类模板实现，用于存储和管理数据，支持对象的添加、删除、索引、遍历等功能。\n2. 容器分类 2.1. 序列容器 容器成员按严格的线性顺序排列，例如：array、vector、list、forward_list、deque、basic_string。\n2.2. 关联容器 就是“键值对”： set/map/multiset/multimap底层使用红黑树实现。\nunordered_set/unordered_map/unordered_multiset/unordered_multimap底层使用哈希表实现。\n2.3. 适配器 对原有容器进行包装、扩展，得到一个新容器。\n2.4. 生成器 构造元素序列。\n3. 容器迭代器 指定容器中的一段区间，用于遍历容器中的元素。 常用迭代器：\n1 2 begin()： end()： 1 2 rbegin()： rend()： # 指向第一个元素的前一个位置 1 cbegin()： 1 2 crbegin()： crend()： 迭代器分为5类，支持的操作集合不同。\n不是所有的容器都支持迭代器，支持迭代器的容器称为range。\n","date":"2025-05-04T00:00:00Z","permalink":"https://zuoco.github.io/p/%E7%AC%AC1%E8%8A%82-%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%B9%E5%99%A8%E5%AE%B9%E5%99%A8%E5%88%86%E7%B1%BB/","title":"第1节 - 什么是容器、容器分类"},{"content":"1. operator\u0026lt;=\u0026gt; \u0026lt;=\u0026gt;目的在于简化自定义类型的比较逻辑，只要实现了\u0026lt;=\u0026gt;和==，编译器就会自动生成其他比较运算逻辑。\n返回值类型为三种比较类别类型：\n1 2 3 std::strong_ordering std::weak_ordering std::partial_ordering 下面介绍这三种比较类型：\n1.1. std::strong_ordering 当两个对象之间存在完全可比较的强序关系时使用，也就是说两个对象之间可以明确的判断出谁大谁小。 返回值：\n1 2 3 std::strong_ordering::less // 左操作数小于右操作数 std::strong_ordering::equal // 左操作数等于右操作数 std::strong_ordering::greater // 左操作数大于右操作数 1.2. std::weak_ordering 当两个对象之间存在弱序关系时，这意味着两者之间可以比较大小，但是有时不会完全相等，比如说大小写，但是std::weak_ordering依然视为相等，所以在需要忽略大小写时，以及其他将“非完全相等”视为“相等”时，使用std::weak_ordering。 返回值：\n1 2 3 std::weak_ordering::less // 左操作数小于右操作数 std::weak_ordering::equivalent // 左操作数等于右操作数 std::weak_ordering::greater // 左操作数大于右操作数 1.3. std::partial_ordering 如果两个对象在某些情况下无法进行对比，例如:\n1 2 double x = 1.0/0.0; //InF double y = 1.0/0.0; //NaN a和b的值无法进行比较，所以返回std::partial_ordering::unordered。 返回值：\n1 2 3 4 std::partial_ordering::less // 左操作数小于右操作数 std::partial_ordering::equivalent // 左操作数等于右操作数 std::partial_ordering::greater // 左操作数大于右操作数 std::partial_ordering::unordered // 左操作数和右操作数不相等 2. 类型转换 std::strong_ordering可以隐式转换为std::weak_ordering，\nstd::weak_ordering可以隐式转换为std::partial_ordering。\n实现 对于简单类型，使用**=default**，让编译器自动生成比较逻辑，对于复杂类型需要手动实现比较逻辑。\n","date":"2025-05-04T00:00:00Z","image":"https://zuoco.github.io/p/%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/AAA_hu_c7ffdc190379ce2e.jpg","permalink":"https://zuoco.github.io/p/%E4%B8%89%E8%B7%AF%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/","title":"三路比较运算符"},{"content":"1. vector 模板类，动态数组，维护一块连续的存储空间，容量可动态改变。 size: 当前元素个数。 cap: 当前容量。 buffer: 指向一块连续的存储空间。\n2. 容量 empty、size，capacity方法。 shrink_to_fit()，如果不再需要填充元素了，那就可以调用shrink_to_fit()方法，将容量缩减到size大小。本质就是在申请一块size大小的内存，然后将原来的元素拷贝到新的内存中，然后释放原来的内存。 3. 访问 下标访问，和array一样，可以使用[]访问元素。 支持front、back、data方法。 swap方法，交换两个vector对象，实际是交换指针，所以比array要快(注意是交换两个vector对象，而不是一个vector对象中的两个元素)。 关于swap方法，有一个常用的技巧是结合它来“清空”一个向量并释放其内存: 1 std::vector\u0026lt;int\u0026gt;().swap(vec1); std::vector\u0026lt;int\u0026gt;() 创建了一个临时的、空的 vector 对象，.swap(vec1) 调用了这个临时对象的 swap 方法，将它与 vec1 的内容交换。\n交换后，vec1 变成一个空的 vector（和临时对象交换后的结果），临时对象现在持有原来 vec1 的所有内存资源，当这行语句结束时，临时对象超出作用域并被销毁，它所持有的内存也被一并释放，如果使用clear()，则vec1会被清空，容量没有重置，内存不会被释放。\n4. 比较 和array不同，vector的大小可以动态改变，即使是大小不同的两个vector对象也可以比较，但是元素类型还是要相同的。\n5. 构造vector对象 5.1. reserve 1 2 3 // 构造一个初始容量为1024的vector对象。 std::vector\u0026lt;int\u0026gt; v; v.reserve(1024); 1 2 // vecitor对象的初始容量为6，每个元素的值都被初始化为1024。 std::vector\u0026lt;int\u0026gt; v(6, 1024); 5.2. push_back和emplace_back 两者都是向容器末尾添加元素，但是工作原理不同：\npush_back: 将一个已经构造好的对象添加到容器的末尾，若传递右值（如临时对象），会调用移动构造函数（若存在）；若传递左值，则调用拷贝构造函数，也就是涉及到拷贝。\n1 2 3 4 std::vector\u0026lt;Person\u0026gt; vec; Person alice(\u0026#34;Alice\u0026#34;, 30); vec.push_back(alice); // 拷贝构造 vec.push_back(Person(\u0026#34;Bob\u0026#34;, 25)); // 移动构造 emplace_back: 直接传递构造对象所需的参数列表，通过完美转发在容器内存中直接构造对象，避免临时对象的创建，也就是在容器末尾原地构造一个对象出来。\n1 vec.emplace_back(\u0026#34;Charlie\u0026#34;, 40); // 直接构造，无拷贝或移动 6. 移除 6.1. insert和emplace 两者都是向容器中指定位置插入元素，返回指向新插入元素的迭代器，区别参考push_back和emplace_back。\n两个第一个参数都是迭代器，新元素会插入到迭代器指向的元素之前。\ninsert:\n1 2 3 4 5 6 7 8 9 10 iterator insert( const_iterator pos, const T\u0026amp; value ); // (1) (constexpr since C++20) iterator insert( const_iterator pos, T\u0026amp;\u0026amp; value ); // (2) (since C++11) (constexpr since C++20) iterator insert( const_iterator pos, size_type count, const T\u0026amp; value ); // (3) (constexpr since C++20) template\u0026lt; class InputIt \u0026gt; iterator insert( const_iterator pos, InputIt first, InputIt last ); // (4) (constexpr since C++20) iterator insert( const_iterator pos, std::initializer_list\u0026lt;T\u0026gt; ilist ); emplace:\n1 2 template\u0026lt; class... Args \u0026gt; iterator emplace( const_iterator pos, Args\u0026amp;\u0026amp;... args ); //(since C++11) (constexpr since C++20) 6.2. pop_back和erase和clear pop_back:\n1 void pop_back(); // (constexpr since C++20) 移除最后一个元素。\nerase:\n1 2 iterator erase( const_iterator pos ); // (since C++11) (constexpr since C++20) iterator erase( const_iterator first, const_iterator last ); // (since C++11) (constexpr since C++20) 移除指定位置的元素，后边的元素要前移，因为vector是连续存储的。\nclear:\n1 void clear(); // (constexpr since C++20) 移除 vector 中所有元素，使其size()变为0，但是容量（capacity()）不变。clear() 会遍历容器中的每个元素，并调用其析构函数。这一步的目的是销毁对象的逻辑内容（如释放对象内部动态分配的资源），但vector对象申请的内存不会被释放。\n7. 内存释放 clear() 不释放内存：若需释放内存，需手动调用 shrink_to_fit()（但这是非强制请求）：\n1 2 vec.clear(); vec.shrink_to_fit(); // 请求释放未使用内存，capacity() 可能变为 0 替代方案：直接赋值空容器（更简洁）：\n1 vec = {}; // 等价于 clear() + shrink_to_fit()（依赖实现，可能释放内存） 8. 其他 不提供push_front和pop_front方法。 写操作可能会导致迭代器失效，就是发生变化了，这个迭代器指向的已经不是原来的那个元素了。\n","date":"2025-05-04T00:03:33+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC2%E8%8A%82-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8Bvector/","title":"第2节 - 序列容器之vector"},{"content":"1. Array 元素数个数固定，不能动态改变。\n1 2 3 4 template\u0026lt; class T, std::size_t N \u0026gt; struct array; 2. 用法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;array\u0026gt; int main() { // 1. 声明一个包含5个整数的数组 std::array\u0026lt;int, 5\u0026gt; arr = {1, 2, 3, 4, 5}; // std::array\u0026lt;int, 5\u0026gt; arr = {1}; 其同元素初始化为0 // 2. 访问数组元素 std::cout \u0026lt;\u0026lt; \u0026#34;First element: \u0026#34; \u0026lt;\u0026lt; arr[0] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Second element: \u0026#34; \u0026lt;\u0026lt; arr[1] \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;arr.at(10) = \u0026#34; \u0026lt;\u0026lt; arr.at(10) \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // 越界访问会崩溃 // 3. 遍历数组 std::ranges::sort(arr); // 使用 C++20 的 std::ranges::sort 对 std::array 排序 for (const auto\u0026amp; elem : arr) { std::cout \u0026lt;\u0026lt; elem \u0026lt;\u0026lt; \u0026#39; \u0026#39;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; // 4. 访问数组的第一个和最后一个元素 std::cout \u0026lt;\u0026lt; \u0026#34;First element: \u0026#34; \u0026lt;\u0026lt; arr.front() \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; \u0026#34;Last element: \u0026#34; \u0026lt;\u0026lt; arr.back() \u0026lt;\u0026lt; std::endl; } 2.1. 原始数组 返回一个指向数组第一个元素的指针，也就是类似于C语言中的数组用法，用在和C语言交互的场景中。\n2.2. 容量方法 对于std::array，empty() 、size() 、max_size()，这些在编译期就确定了，所以运行时调用这些方法没有意义。那么为什么还要提供这些方法呢？因为这些方法在其他容器中是有意义的，为了统一接口，这些方法在std::array中也提供了。\n2.3. 迭代器 以正向迭代器为例：\n1 2 3 4 5 std::cout \u0026lt;\u0026lt; \u0026#34;Using forward iterator:\\n\u0026#34;; for (auto it = arr.begin(); it != arr.end(); ++it) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; 2.4. 数组填充 用于将容器中的所有元素都设置为指定的值。\n1 2 void fill( const T\u0026amp; value ); // (since C++11) // (constexpr since C++20) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include \u0026lt;array\u0026gt; #include \u0026lt;cstddef\u0026gt; #include \u0026lt;iostream\u0026gt; int main() { constexpr std::size_t xy = 4; using Cell = std::array\u0026lt;unsigned char, 8\u0026gt;; std::array\u0026lt;Cell, xy * xy\u0026gt; board; board.fill({0xE2, 0x96, 0x84, 0xE2, 0x96, 0x80, 0, 0}); // \u0026#34;▄▀\u0026#34;; for (std::size_t count{}; Cell c : board) std::cout \u0026lt;\u0026lt; c.data() \u0026lt;\u0026lt; ((++count % xy) ? \u0026#34;\u0026#34; : \u0026#34;\\n\u0026#34;); } 输出：\n1 2 3 4 ▄▀▄▀▄▀▄▀ ▄▀▄▀▄▀▄▀ ▄▀▄▀▄▀▄▀ ▄▀▄▀▄▀▄▀ 这个比较有趣，是一个棋盘，讲解一下：\n这个棋盘由16个“▄▀”组成，每个“▄▀”在代码中用一个Cell表示，对于每个Cell:\n1 Cell c = {0xE2, 0x96, 0x84, 0xE2, 0x96, 0x80, 0, 0}; 0xE2, 0x96, 0x84打印出来就是“▄”，而0xE2, 0x96, 0x80打印出来就是“▀”， 0, 0确保字符串以空字符结尾，因为代码中使用了data()方法。\n2.5. 元素交换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include \u0026lt;array\u0026gt; #include \u0026lt;iostream\u0026gt; /* * 重载“\u0026lt;\u0026lt;” */ template\u0026lt;class Os, class V\u0026gt; Os\u0026amp; operator\u0026lt;\u0026lt;(Os\u0026amp; os, const V\u0026amp; v) { os \u0026lt;\u0026lt; \u0026#39;{\u0026#39;; for (auto i : v) os \u0026lt;\u0026lt; \u0026#39; \u0026#39; \u0026lt;\u0026lt; i; return os \u0026lt;\u0026lt; \u0026#34; } \u0026#34;; } int main() { std::array\u0026lt;int, 3\u0026gt; a1{1, 2, 3}, a2{4, 5, 6}; auto it1 = a1.begin(); auto it2 = a2.begin(); int\u0026amp; ref1 = a1[1]; int\u0026amp; ref2 = a2[1]; std::cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; a2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; a1.swap(a2); std::cout \u0026lt;\u0026lt; a1 \u0026lt;\u0026lt; a2 \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; } 这里简单介绍以下“\u0026laquo;”的工作原理：\n1 template\u0026lt;class Os, class V\u0026gt; Os\u0026amp; operator\u0026lt;\u0026lt;(Os\u0026amp; os, const V\u0026amp; v) 函数模板，根据传递的参数进行推导，实例化模板函数，返回Os引用，以便于链式调用：\n1 operator\u0026lt;\u0026lt;(operator\u0026lt;\u0026lt;(std::cout, a1), a2); 2.6. 比较 1 2 operator== (C++11) operator\u0026lt;=\u0026gt; (C++20) 2.6.1. operator== 1 2 3 // (since C++11) (constexpr since C++20) template\u0026lt; class T, std::size_t N \u0026gt; bool operator==( const std::array\u0026lt;T, N\u0026gt;\u0026amp; lhs, const std::array\u0026lt;T, N\u0026gt;\u0026amp; rhs ); 要求双方类型相同。\n1 2 std::array\u0026lt;int, 3\u0026gt; x; std::array\u0026lt;int, 4\u0026gt; y; x和y的类型不同，所以不能比较。\n2.6.2. operator\u0026lt;=\u0026gt; 用法见《逻辑比较》。\n","date":"2025-05-04T00:03:33+08:00","permalink":"https://zuoco.github.io/p/%E7%AC%AC3%E8%8A%82-%E5%BA%8F%E5%88%97%E5%AE%B9%E5%99%A8%E4%B9%8Barray/","title":"第3节 - 序列容器之Array"},{"content":"1. 概述 ","date":"2025-05-04T00:01:49+08:00","image":"https://zuoco.github.io/p/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/%E3%80%90%E5%93%B2%E9%A3%8E%E5%A3%81%E7%BA%B8%E3%80%91%E5%A4%9C%E6%99%AF-%E6%98%9F%E7%A9%BA-%E6%9C%88%E4%BA%AE_hu_61f7f66a3bd8c453.png","permalink":"https://zuoco.github.io/p/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","title":"动态内存管理"},{"content":"1. 非格式化IO 非格式化IO不涉及数据表示形式的变化。\n非格式化输入： get、read、getline、gcount\n格式化输出： put、write\n2. 格式化IO 使用移位操作符（“\u0026laquo;”、“\u0026raquo;”）来进行格式化输出，类型通过重载移位操作符来提供格式化IO功能。\n2.1. 格式控制 位掩码类型\n1 2 3 4 5 6 7 8 9 int main() { int x = 888; int y = -888; char z = \u0026#39;6\u0026#39;; std::cout.setf(std::ios_base::showpos); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; std::cout \u0026lt;\u0026lt; z \u0026lt;\u0026lt; std::endl; // showpos对于char类型无效 } 输出：\n+999\n-888\n6\n输出宽度控制 1 2 3 4 5 6 7 int main() { int x = 100; std::cout.width(10); std::cout.setf(std::ios_base::showpos); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } // 输出， 以空格填充： +100 1 2 3 4 5 6 7 8 int main() { int x = 100; std::cout.width(10); // 触发后就会被重置为0 std::cout.fill(\u0026#39;.\u0026#39;); std::cout.setf(std::ios_base::showpos); std::cout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl; } // 输出: ......+100 操纵符 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; int main() { int x = 666; int y = 888; // std::setw()出发后就会被重置 std::cout \u0026lt;\u0026lt; std::showpos \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::setw(10) \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; } ","date":"2020-09-09T00:00:00Z","image":"https://zuoco.github.io/p/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/aaa_hu_2ce571a144f0c271.jpg","permalink":"https://zuoco.github.io/p/%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA/","title":"输入输出"}]